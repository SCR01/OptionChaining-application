{"ast":null,"code":"// WebSocket service using a Web Worker for improved performance\nimport { toast } from 'react-toastify';\nlet worker = null;\nlet eventHandlers = {\n  onInitialData: null,\n  onPriceUpdate: null,\n  onSubscriptionUpdate: null,\n  onConnectionStatus: null,\n  onReconnecting: null,\n  onError: null\n};\nlet isConnected = false;\nlet isInitialized = false;\nlet activeSubscriptions = []; // Track active subscriptions across component mounts\n\n// Dynamic server URL based on environment\nconst getWebSocketUrl = () => {\n  // For production deployments\n  if (process.env.NODE_ENV === 'production') {\n    // Use the API_URL environment variable if set, otherwise use relative path\n    if (process.env.REACT_APP_API_URL) {\n      return process.env.REACT_APP_API_URL.replace(/^http/, 'ws');\n    }\n    // Fallback to same domain WebSocket\n    return `ws://${window.location.host}/ws`;\n  }\n\n  // For local development\n  return 'ws://localhost:5000';\n};\n\n// Initialize the worker\nconst initializeWorker = () => {\n  if (worker) return;\n  try {\n    // Create the worker\n    worker = new Worker(new URL('../workers/websocketWorker.js', import.meta.url));\n    console.log('WebSocket worker created');\n\n    // Set up message listener\n    worker.onmessage = event => {\n      const message = event.data;\n      switch (message.type) {\n        case 'INITIAL_DATA':\n          if (eventHandlers.onInitialData) {\n            eventHandlers.onInitialData(message.data);\n          }\n          break;\n        case 'PRICE_UPDATE':\n          if (eventHandlers.onPriceUpdate) {\n            eventHandlers.onPriceUpdate(message.updates);\n          }\n          break;\n        case 'SUBSCRIPTION_UPDATE':\n          if (message.subscriptions) {\n            activeSubscriptions = [...message.subscriptions]; // Update cached subscriptions\n          }\n          if (eventHandlers.onSubscriptionUpdate) {\n            eventHandlers.onSubscriptionUpdate(message.subscriptions);\n          }\n          break;\n        case 'CONNECTION_STATUS':\n          isConnected = message.status === 'CONNECTED';\n          if (eventHandlers.onConnectionStatus) {\n            eventHandlers.onConnectionStatus(isConnected);\n          }\n          break;\n        case 'RECONNECTING':\n          if (eventHandlers.onReconnecting) {\n            eventHandlers.onReconnecting(message.attempt, message.maxAttempts);\n          }\n          break;\n        case 'ERROR':\n          if (eventHandlers.onError) {\n            eventHandlers.onError(message.error);\n          }\n          console.error('WebSocket error:', message.error);\n          toast.error(message.error);\n          break;\n        default:\n          console.log('Unknown message type:', message.type);\n      }\n    };\n\n    // Initialize connection\n    worker.postMessage({\n      type: 'CONNECT',\n      url: getWebSocketUrl()\n    });\n  } catch (error) {\n    console.error('Error initializing WebSocket worker:', error);\n    toast.error('Failed to initialize WebSocket worker: ' + error.message);\n  }\n};\n\n// Connect to WebSocket and set up event handlers\nconst connectToWebSocket = handlers => {\n  // Initialize handler references\n  Object.keys(handlers || {}).forEach(key => {\n    if (handlers[key]) {\n      eventHandlers[key] = handlers[key];\n    }\n  });\n\n  // Initialize worker if needed\n  if (!isInitialized) {\n    initializeWorker();\n    isInitialized = true;\n  } else {\n    // Update the new component with the current connection status\n    if (eventHandlers.onConnectionStatus) {\n      setTimeout(() => {\n        eventHandlers.onConnectionStatus(isConnected);\n      }, 0);\n    }\n\n    // Request current data if connected\n    if (isConnected && eventHandlers.onInitialData) {\n      worker.postMessage({\n        type: 'GET_INITIAL_DATA'\n      });\n    }\n\n    // Update new component with current subscriptions\n    if (activeSubscriptions.length > 0 && eventHandlers.onSubscriptionUpdate) {\n      setTimeout(() => {\n        eventHandlers.onSubscriptionUpdate(activeSubscriptions);\n      }, 0);\n    }\n  }\n};\n\n// Subscribe to tokens\nconst subscribeToTokens = tokens => {\n  if (!worker) {\n    console.error('Worker not initialized. Call connectToWebSocket first.');\n    return;\n  }\n  if (!Array.isArray(tokens)) {\n    tokens = [tokens];\n  }\n\n  // Update our cache of active subscriptions\n  tokens.forEach(token => {\n    if (!activeSubscriptions.includes(token)) {\n      activeSubscriptions.push(token);\n    }\n  });\n  worker.postMessage({\n    type: 'SUBSCRIBE',\n    tokens\n  });\n};\n\n// Unsubscribe from tokens\nconst unsubscribeFromTokens = tokens => {\n  if (!worker) {\n    console.error('Worker not initialized. Call connectToWebSocket first.');\n    return;\n  }\n  if (!Array.isArray(tokens)) {\n    tokens = [tokens];\n  }\n\n  // Update our cache of active subscriptions\n  activeSubscriptions = activeSubscriptions.filter(token => !tokens.includes(token));\n  worker.postMessage({\n    type: 'UNSUBSCRIBE',\n    tokens\n  });\n};\n\n// Disconnect from WebSocket\nconst disconnect = () => {\n  if (worker) {\n    // Clear all subscriptions on disconnect\n    activeSubscriptions = [];\n    worker.postMessage({\n      type: 'DISCONNECT'\n    });\n  }\n};\n\n// Check connection status\nconst getConnectionStatus = () => {\n  if (worker) {\n    worker.postMessage({\n      type: 'GET_CONNECTION_STATUS'\n    });\n  }\n  return isConnected;\n};\n\n// Get currently active subscriptions\nconst getActiveSubscriptions = () => {\n  return [...activeSubscriptions];\n};\nexport { connectToWebSocket, subscribeToTokens, unsubscribeFromTokens, disconnect, getConnectionStatus, getActiveSubscriptions };","map":{"version":3,"names":["toast","worker","eventHandlers","onInitialData","onPriceUpdate","onSubscriptionUpdate","onConnectionStatus","onReconnecting","onError","isConnected","isInitialized","activeSubscriptions","getWebSocketUrl","process","env","NODE_ENV","REACT_APP_API_URL","replace","window","location","host","initializeWorker","Worker","URL","import","meta","url","console","log","onmessage","event","message","data","type","updates","subscriptions","status","attempt","maxAttempts","error","postMessage","connectToWebSocket","handlers","Object","keys","forEach","key","setTimeout","length","subscribeToTokens","tokens","Array","isArray","token","includes","push","unsubscribeFromTokens","filter","disconnect","getConnectionStatus","getActiveSubscriptions"],"sources":["C:/Users/scr/OneDrive/Desktop/new/frontend/src/services/websocketService.js"],"sourcesContent":["// WebSocket service using a Web Worker for improved performance\nimport { toast } from 'react-toastify';\n\nlet worker = null;\nlet eventHandlers = {\n  onInitialData: null,\n  onPriceUpdate: null,\n  onSubscriptionUpdate: null,\n  onConnectionStatus: null,\n  onReconnecting: null,\n  onError: null\n};\nlet isConnected = false;\nlet isInitialized = false;\nlet activeSubscriptions = []; // Track active subscriptions across component mounts\n\n// Dynamic server URL based on environment\nconst getWebSocketUrl = () => {\n  // For production deployments\n  if (process.env.NODE_ENV === 'production') {\n    // Use the API_URL environment variable if set, otherwise use relative path\n    if (process.env.REACT_APP_API_URL) {\n      return process.env.REACT_APP_API_URL.replace(/^http/, 'ws');\n    }\n    // Fallback to same domain WebSocket\n    return `ws://${window.location.host}/ws`;\n  }\n  \n  // For local development\n  return 'ws://localhost:5000';\n};\n\n// Initialize the worker\nconst initializeWorker = () => {\n  if (worker) return;\n  \n  try {\n    // Create the worker\n    worker = new Worker(new URL('../workers/websocketWorker.js', import.meta.url));\n    \n    console.log('WebSocket worker created');\n    \n    // Set up message listener\n    worker.onmessage = (event) => {\n      const message = event.data;\n      \n      switch (message.type) {\n        case 'INITIAL_DATA':\n          if (eventHandlers.onInitialData) {\n            eventHandlers.onInitialData(message.data);\n          }\n          break;\n        case 'PRICE_UPDATE':\n          if (eventHandlers.onPriceUpdate) {\n            eventHandlers.onPriceUpdate(message.updates);\n          }\n          break;\n        case 'SUBSCRIPTION_UPDATE':\n          if (message.subscriptions) {\n            activeSubscriptions = [...message.subscriptions]; // Update cached subscriptions\n          }\n          if (eventHandlers.onSubscriptionUpdate) {\n            eventHandlers.onSubscriptionUpdate(message.subscriptions);\n          }\n          break;\n        case 'CONNECTION_STATUS':\n          isConnected = message.status === 'CONNECTED';\n          if (eventHandlers.onConnectionStatus) {\n            eventHandlers.onConnectionStatus(isConnected);\n          }\n          break;\n        case 'RECONNECTING':\n          if (eventHandlers.onReconnecting) {\n            eventHandlers.onReconnecting(message.attempt, message.maxAttempts);\n          }\n          break;\n        case 'ERROR':\n          if (eventHandlers.onError) {\n            eventHandlers.onError(message.error);\n          }\n          console.error('WebSocket error:', message.error);\n          toast.error(message.error);\n          break;\n        default:\n          console.log('Unknown message type:', message.type);\n      }\n    };\n    \n    // Initialize connection\n    worker.postMessage({ type: 'CONNECT', url: getWebSocketUrl() });\n    \n  } catch (error) {\n    console.error('Error initializing WebSocket worker:', error);\n    toast.error('Failed to initialize WebSocket worker: ' + error.message);\n  }\n};\n\n// Connect to WebSocket and set up event handlers\nconst connectToWebSocket = (handlers) => {\n  // Initialize handler references\n  Object.keys(handlers || {}).forEach(key => {\n    if (handlers[key]) {\n      eventHandlers[key] = handlers[key];\n    }\n  });\n  \n  // Initialize worker if needed\n  if (!isInitialized) {\n    initializeWorker();\n    isInitialized = true;\n  } else {\n    // Update the new component with the current connection status\n    if (eventHandlers.onConnectionStatus) {\n      setTimeout(() => {\n        eventHandlers.onConnectionStatus(isConnected);\n      }, 0);\n    }\n    \n    // Request current data if connected\n    if (isConnected && eventHandlers.onInitialData) {\n      worker.postMessage({ type: 'GET_INITIAL_DATA' });\n    }\n    \n    // Update new component with current subscriptions\n    if (activeSubscriptions.length > 0 && eventHandlers.onSubscriptionUpdate) {\n      setTimeout(() => {\n        eventHandlers.onSubscriptionUpdate(activeSubscriptions);\n      }, 0);\n    }\n  }\n};\n\n// Subscribe to tokens\nconst subscribeToTokens = (tokens) => {\n  if (!worker) {\n    console.error('Worker not initialized. Call connectToWebSocket first.');\n    return;\n  }\n  \n  if (!Array.isArray(tokens)) {\n    tokens = [tokens];\n  }\n  \n  // Update our cache of active subscriptions\n  tokens.forEach(token => {\n    if (!activeSubscriptions.includes(token)) {\n      activeSubscriptions.push(token);\n    }\n  });\n  \n  worker.postMessage({\n    type: 'SUBSCRIBE',\n    tokens\n  });\n};\n\n// Unsubscribe from tokens\nconst unsubscribeFromTokens = (tokens) => {\n  if (!worker) {\n    console.error('Worker not initialized. Call connectToWebSocket first.');\n    return;\n  }\n  \n  if (!Array.isArray(tokens)) {\n    tokens = [tokens];\n  }\n  \n  // Update our cache of active subscriptions\n  activeSubscriptions = activeSubscriptions.filter(token => !tokens.includes(token));\n  \n  worker.postMessage({\n    type: 'UNSUBSCRIBE',\n    tokens\n  });\n};\n\n// Disconnect from WebSocket\nconst disconnect = () => {\n  if (worker) {\n    // Clear all subscriptions on disconnect\n    activeSubscriptions = [];\n    worker.postMessage({ type: 'DISCONNECT' });\n  }\n};\n\n// Check connection status\nconst getConnectionStatus = () => {\n  if (worker) {\n    worker.postMessage({ type: 'GET_CONNECTION_STATUS' });\n  }\n  return isConnected;\n};\n\n// Get currently active subscriptions\nconst getActiveSubscriptions = () => {\n  return [...activeSubscriptions];\n};\n\nexport {\n  connectToWebSocket,\n  subscribeToTokens,\n  unsubscribeFromTokens,\n  disconnect,\n  getConnectionStatus,\n  getActiveSubscriptions\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}