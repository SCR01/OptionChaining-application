{"ast":null,"code":"/* eslint-disable no-restricted-globals */\n// WebSocket Worker\nlet socket = null;\nlet reconnectInterval = null;\nlet reconnectAttempts = 0;\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst BASE_RECONNECT_DELAY = 1000;\n\n// Connect to WebSocket server\nconst connectToWebSocket = () => {\n  try {\n    const wsUrl = 'ws://localhost:5000';\n    console.log(`[Worker] Connecting to WebSocket at ${wsUrl}`);\n\n    // Close any existing socket\n    if (socket) {\n      socket.close();\n    }\n    socket = new WebSocket(wsUrl);\n    socket.onopen = () => {\n      console.log('[Worker] WebSocket connection established');\n      // Reset reconnect attempts on successful connection\n      reconnectAttempts = 0;\n      // Clear any pending reconnect interval\n      if (reconnectInterval) {\n        clearInterval(reconnectInterval);\n        reconnectInterval = null;\n      }\n      // Notify main thread of connection\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        status: 'CONNECTED'\n      });\n    };\n    socket.onmessage = event => {\n      try {\n        const message = JSON.parse(event.data);\n        handleMessage(message);\n      } catch (error) {\n        console.error('[Worker] Error parsing message:', error);\n      }\n    };\n    socket.onclose = event => {\n      console.log(`[Worker] WebSocket connection closed: ${event.code} ${event.reason}`);\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        status: 'DISCONNECTED'\n      });\n\n      // Attempt to reconnect if not closing cleanly\n      if (event.code !== 1000) {\n        attemptReconnect();\n      }\n    };\n    socket.onerror = error => {\n      console.error('[Worker] WebSocket error:', error);\n      self.postMessage({\n        type: 'ERROR',\n        error: 'Failed to connect to WebSocket server. Please check if the server is running.'\n      });\n    };\n  } catch (error) {\n    console.error('[Worker] Error connecting to WebSocket:', error);\n    self.postMessage({\n      type: 'ERROR',\n      error: 'Failed to connect to WebSocket server. Please check if the server is running.'\n    });\n\n    // Attempt to reconnect on error\n    attemptReconnect();\n  }\n};\n\n// Attempt to reconnect with exponential backoff\nconst attemptReconnect = () => {\n  if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n    console.log('[Worker] Maximum reconnect attempts reached, giving up');\n    self.postMessage({\n      type: 'ERROR',\n      error: 'Failed to reconnect to the server after multiple attempts. Please refresh the page.'\n    });\n    return;\n  }\n\n  // Clear any existing reconnect interval\n  if (reconnectInterval) {\n    clearInterval(reconnectInterval);\n  }\n\n  // Calculate delay with exponential backoff\n  const delay = BASE_RECONNECT_DELAY * Math.pow(2, reconnectAttempts);\n  console.log(`[Worker] Attempting to reconnect in ${delay}ms (attempt ${reconnectAttempts + 1}/${MAX_RECONNECT_ATTEMPTS})`);\n  reconnectInterval = setTimeout(() => {\n    reconnectAttempts++;\n    connectToWebSocket();\n  }, delay);\n};\n\n// Handle incoming WebSocket messages\nconst handleMessage = message => {\n  switch (message.type) {\n    case 'INITIAL_DATA':\n      console.log('[Worker] Received initial data');\n      self.postMessage({\n        type: 'INITIAL_DATA',\n        data: message.data\n      });\n      break;\n    case 'PRICE_UPDATE':\n      // Forward price updates directly to main thread\n      self.postMessage({\n        type: 'PRICE_UPDATE',\n        updates: message.updates\n      });\n      break;\n    case 'PONG':\n      // Just log pongs, no need to forward\n      console.log('[Worker] Received pong from server');\n      break;\n    default:\n      console.log(`[Worker] Received unknown message type: ${message.type}`);\n  }\n};\n\n// Subscribe to tokens\nconst subscribeToTokens = tokens => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.error('[Worker] Cannot subscribe, WebSocket not connected');\n    return;\n  }\n  console.log(`[Worker] Subscribing to tokens: ${tokens.join(', ')}`);\n  socket.send(JSON.stringify({\n    type: 'SUBSCRIBE',\n    tokens\n  }));\n};\n\n// Unsubscribe from tokens\nconst unsubscribeFromTokens = tokens => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.error('[Worker] Cannot unsubscribe, WebSocket not connected');\n    return;\n  }\n  console.log(`[Worker] Unsubscribing from tokens: ${tokens.join(', ')}`);\n  socket.send(JSON.stringify({\n    type: 'UNSUBSCRIBE',\n    tokens\n  }));\n};\n\n// Send ping to keep connection alive\nconst ping = () => {\n  if (socket && socket.readyState === WebSocket.OPEN) {\n    socket.send(JSON.stringify({\n      type: 'PING'\n    }));\n  }\n};\n\n// Initialize ping interval\nconst startPingInterval = () => {\n  setInterval(ping, 30000); // Send ping every 30 seconds\n};\n\n// Handle messages from main thread\nself.onmessage = event => {\n  const message = event.data;\n  switch (message.type) {\n    case 'CONNECT':\n      connectToWebSocket();\n      startPingInterval();\n      break;\n    case 'SUBSCRIBE':\n      subscribeToTokens(message.tokens);\n      break;\n    case 'UNSUBSCRIBE':\n      unsubscribeFromTokens(message.tokens);\n      break;\n    default:\n      console.log(`[Worker] Received unknown message from main thread: ${message.type}`);\n  }\n};\nself.postMessage({\n  type: 'CONNECTION_STATUS',\n  status: 'DISCONNECTED'\n});\nself.onmessage({\n  data: {\n    type: 'CONNECT'\n  }\n});","map":{"version":3,"names":["socket","reconnectInterval","reconnectAttempts","MAX_RECONNECT_ATTEMPTS","BASE_RECONNECT_DELAY","connectToWebSocket","wsUrl","console","log","close","WebSocket","onopen","clearInterval","self","postMessage","type","status","onmessage","event","message","JSON","parse","data","handleMessage","error","onclose","code","reason","attemptReconnect","onerror","delay","Math","pow","setTimeout","updates","subscribeToTokens","tokens","readyState","OPEN","join","send","stringify","unsubscribeFromTokens","ping","startPingInterval","setInterval"],"sources":["C:/Users/scr/OneDrive/Desktop/new/frontend/src/workers/websocketWorker.js"],"sourcesContent":["/* eslint-disable no-restricted-globals */\n// WebSocket Worker\nlet socket = null;\nlet reconnectInterval = null;\nlet reconnectAttempts = 0;\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst BASE_RECONNECT_DELAY = 1000;\n\n// Connect to WebSocket server\nconst connectToWebSocket = () => {\n  try {\n    const wsUrl = 'ws://localhost:5000';\n    console.log(`[Worker] Connecting to WebSocket at ${wsUrl}`);\n    \n    // Close any existing socket\n    if (socket) {\n      socket.close();\n    }\n    \n    socket = new WebSocket(wsUrl);\n    \n    socket.onopen = () => {\n      console.log('[Worker] WebSocket connection established');\n      // Reset reconnect attempts on successful connection\n      reconnectAttempts = 0;\n      // Clear any pending reconnect interval\n      if (reconnectInterval) {\n        clearInterval(reconnectInterval);\n        reconnectInterval = null;\n      }\n      // Notify main thread of connection\n      self.postMessage({ type: 'CONNECTION_STATUS', status: 'CONNECTED' });\n    };\n    \n    socket.onmessage = (event) => {\n      try {\n        const message = JSON.parse(event.data);\n        handleMessage(message);\n      } catch (error) {\n        console.error('[Worker] Error parsing message:', error);\n      }\n    };\n    \n    socket.onclose = (event) => {\n      console.log(`[Worker] WebSocket connection closed: ${event.code} ${event.reason}`);\n      self.postMessage({ type: 'CONNECTION_STATUS', status: 'DISCONNECTED' });\n      \n      // Attempt to reconnect if not closing cleanly\n      if (event.code !== 1000) {\n        attemptReconnect();\n      }\n    };\n    \n    socket.onerror = (error) => {\n      console.error('[Worker] WebSocket error:', error);\n      self.postMessage({ \n        type: 'ERROR', \n        error: 'Failed to connect to WebSocket server. Please check if the server is running.'\n      });\n    };\n  } catch (error) {\n    console.error('[Worker] Error connecting to WebSocket:', error);\n    self.postMessage({ \n      type: 'ERROR', \n      error: 'Failed to connect to WebSocket server. Please check if the server is running.'\n    });\n    \n    // Attempt to reconnect on error\n    attemptReconnect();\n  }\n};\n\n// Attempt to reconnect with exponential backoff\nconst attemptReconnect = () => {\n  if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n    console.log('[Worker] Maximum reconnect attempts reached, giving up');\n    self.postMessage({ \n      type: 'ERROR', \n      error: 'Failed to reconnect to the server after multiple attempts. Please refresh the page.'\n    });\n    return;\n  }\n  \n  // Clear any existing reconnect interval\n  if (reconnectInterval) {\n    clearInterval(reconnectInterval);\n  }\n  \n  // Calculate delay with exponential backoff\n  const delay = BASE_RECONNECT_DELAY * Math.pow(2, reconnectAttempts);\n  console.log(`[Worker] Attempting to reconnect in ${delay}ms (attempt ${reconnectAttempts + 1}/${MAX_RECONNECT_ATTEMPTS})`);\n  \n  reconnectInterval = setTimeout(() => {\n    reconnectAttempts++;\n    connectToWebSocket();\n  }, delay);\n};\n\n// Handle incoming WebSocket messages\nconst handleMessage = (message) => {\n  switch (message.type) {\n    case 'INITIAL_DATA':\n      console.log('[Worker] Received initial data');\n      self.postMessage({\n        type: 'INITIAL_DATA',\n        data: message.data\n      });\n      break;\n      \n    case 'PRICE_UPDATE':\n      // Forward price updates directly to main thread\n      self.postMessage({\n        type: 'PRICE_UPDATE',\n        updates: message.updates\n      });\n      break;\n      \n    case 'PONG':\n      // Just log pongs, no need to forward\n      console.log('[Worker] Received pong from server');\n      break;\n      \n    default:\n      console.log(`[Worker] Received unknown message type: ${message.type}`);\n  }\n};\n\n// Subscribe to tokens\nconst subscribeToTokens = (tokens) => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.error('[Worker] Cannot subscribe, WebSocket not connected');\n    return;\n  }\n  \n  console.log(`[Worker] Subscribing to tokens: ${tokens.join(', ')}`);\n  \n  socket.send(JSON.stringify({\n    type: 'SUBSCRIBE',\n    tokens\n  }));\n};\n\n// Unsubscribe from tokens\nconst unsubscribeFromTokens = (tokens) => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.error('[Worker] Cannot unsubscribe, WebSocket not connected');\n    return;\n  }\n  \n  console.log(`[Worker] Unsubscribing from tokens: ${tokens.join(', ')}`);\n  \n  socket.send(JSON.stringify({\n    type: 'UNSUBSCRIBE',\n    tokens\n  }));\n};\n\n// Send ping to keep connection alive\nconst ping = () => {\n  if (socket && socket.readyState === WebSocket.OPEN) {\n    socket.send(JSON.stringify({ type: 'PING' }));\n  }\n};\n\n// Initialize ping interval\nconst startPingInterval = () => {\n  setInterval(ping, 30000); // Send ping every 30 seconds\n};\n\n// Handle messages from main thread\nself.onmessage = (event) => {\n  const message = event.data;\n  \n  switch (message.type) {\n    case 'CONNECT':\n      connectToWebSocket();\n      startPingInterval();\n      break;\n      \n    case 'SUBSCRIBE':\n      subscribeToTokens(message.tokens);\n      break;\n      \n    case 'UNSUBSCRIBE':\n      unsubscribeFromTokens(message.tokens);\n      break;\n      \n    default:\n      console.log(`[Worker] Received unknown message from main thread: ${message.type}`);\n  }\n};\n\nself.postMessage({ type: 'CONNECTION_STATUS', status: 'DISCONNECTED' });\nself.onmessage({ data: { type: 'CONNECT' } });\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}