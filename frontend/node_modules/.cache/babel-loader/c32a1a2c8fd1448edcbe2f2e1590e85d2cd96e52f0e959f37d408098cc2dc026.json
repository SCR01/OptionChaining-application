{"ast":null,"code":"/* WebSocket Worker\n * This worker handles WebSocket connections independently from the main thread\n * Features:\n * - Auto reconnection on lost connections\n * - Connection status monitoring\n */\n\n/* eslint-disable no-restricted-globals */\n// Using 'self' is standard in web workers, disabling ESLint warning\n\nlet socket = null;\nlet reconnectAttempts = 0;\nconst maxReconnectAttempts = 10;\nconst reconnectInterval = 2000; // 2 seconds\nlet activeSubscriptions = [];\nlet isConnected = false;\n\n// Connection management\nconst connectToWebSocket = () => {\n  // Make sure any existing connection is closed\n  if (socket) {\n    try {\n      socket.onclose = null; // Remove the onclose handler to prevent reconnection loops\n      socket.onerror = null; // Remove the error handler\n      socket.close();\n    } catch (err) {\n      console.error('[Worker] Error closing existing socket:', err);\n    }\n  }\n\n  // Use a hardcoded URL to ensure we connect correctly\n  const wsUrl = 'ws://localhost:5000';\n  console.log(`[Worker] Connecting to WebSocket at ${wsUrl}`);\n  try {\n    socket = new WebSocket(wsUrl);\n    socket.onopen = () => {\n      console.log('[Worker] WebSocket connection established');\n      isConnected = true;\n      reconnectAttempts = 0;\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        isConnected: true\n      });\n\n      // Resubscribe to tokens after reconnection\n      if (activeSubscriptions.length > 0) {\n        subscribeToTokens(activeSubscriptions);\n      }\n\n      // Start sending periodic pings\n      startPingInterval();\n    };\n    socket.onclose = event => {\n      console.log(`[Worker] WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason || 'No reason provided'}, Clean: ${event.wasClean}`);\n      isConnected = false;\n      stopPingInterval();\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        isConnected: false\n      });\n\n      // Only try to reconnect if it wasn't a clean close\n      if (!event.wasClean) {\n        handleReconnect();\n      }\n    };\n    socket.onerror = error => {\n      console.error('[Worker] WebSocket error:', error);\n      self.postMessage({\n        type: 'ERROR',\n        error: 'Connection error. Attempting to reconnect...'\n      });\n    };\n    socket.onmessage = event => {\n      try {\n        const message = JSON.parse(event.data);\n        switch (message.type) {\n          case 'INITIAL_DATA':\n            self.postMessage({\n              type: 'INITIAL_DATA',\n              data: message.data\n            });\n            break;\n          case 'PRICE_UPDATE':\n            // Handle price updates from server\n            self.postMessage({\n              type: 'PRICE_UPDATE',\n              updates: message.updates\n            });\n            break;\n          case 'PONG':\n            // Received pong from the server - connection is active\n            break;\n          default:\n            console.log(`[Worker] Unknown message type: ${message.type}`);\n        }\n      } catch (error) {\n        console.error('[Worker] Error processing message:', error);\n      }\n    };\n  } catch (error) {\n    console.error('[Worker] Error creating WebSocket:', error);\n    isConnected = false;\n    handleReconnect();\n  }\n};\n\n// Handle reconnection with exponential backoff\nconst handleReconnect = () => {\n  if (reconnectAttempts >= maxReconnectAttempts) {\n    console.error('[Worker] Maximum reconnection attempts reached');\n    self.postMessage({\n      type: 'ERROR',\n      error: 'Failed to reconnect after multiple attempts. Please refresh the page.'\n    });\n    return;\n  }\n  const delay = reconnectInterval * Math.pow(1.5, reconnectAttempts);\n  reconnectAttempts++;\n  self.postMessage({\n    type: 'RECONNECTING',\n    attempt: reconnectAttempts,\n    maxAttempts: maxReconnectAttempts\n  });\n  console.log(`[Worker] Reconnecting in ${delay}ms (attempt ${reconnectAttempts}/${maxReconnectAttempts})`);\n  setTimeout(connectToWebSocket, delay);\n};\n\n// Keep-alive mechanism\nlet pingInterval = null;\nconst startPingInterval = () => {\n  stopPingInterval(); // Clear any existing interval\n\n  pingInterval = setInterval(() => {\n    if (socket && socket.readyState === WebSocket.OPEN) {\n      socket.send(JSON.stringify({\n        type: 'PING'\n      }));\n    }\n  }, 30000); // Send ping every 30 seconds\n};\nconst stopPingInterval = () => {\n  if (pingInterval) {\n    clearInterval(pingInterval);\n    pingInterval = null;\n  }\n};\n\n// Token subscription management\nconst subscribeToTokens = tokens => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.warn('[Worker] Cannot subscribe, socket not open');\n    // Save for later when connected\n    tokens.forEach(token => {\n      if (!activeSubscriptions.includes(token)) {\n        activeSubscriptions.push(token);\n      }\n    });\n    return;\n  }\n\n  // Add to active subscriptions\n  tokens.forEach(token => {\n    if (!activeSubscriptions.includes(token)) {\n      activeSubscriptions.push(token);\n    }\n  });\n\n  // Send subscription message\n  socket.send(JSON.stringify({\n    type: 'SUBSCRIBE',\n    tokens: tokens\n  }));\n\n  // Notify the main thread\n  self.postMessage({\n    type: 'SUBSCRIPTION_UPDATE',\n    subscriptions: activeSubscriptions\n  });\n};\nconst unsubscribeFromTokens = tokens => {\n  // Remove from active subscriptions\n  activeSubscriptions = activeSubscriptions.filter(token => !tokens.includes(token));\n  if (socket && socket.readyState === WebSocket.OPEN) {\n    // Send unsubscription message\n    socket.send(JSON.stringify({\n      type: 'UNSUBSCRIBE',\n      tokens: tokens\n    }));\n  }\n\n  // Notify the main thread\n  self.postMessage({\n    type: 'SUBSCRIPTION_UPDATE',\n    subscriptions: activeSubscriptions\n  });\n};\n\n// Handle messages from the main thread\nself.onmessage = event => {\n  const message = event.data;\n  switch (message.type) {\n    case 'SUBSCRIBE':\n      subscribeToTokens(message.tokens);\n      break;\n    case 'UNSUBSCRIBE':\n      unsubscribeFromTokens(message.tokens);\n      break;\n    case 'GET_CONNECTION_STATUS':\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        isConnected: isConnected\n      });\n      break;\n    case 'DISCONNECT':\n      if (socket) {\n        socket.close(1000, 'User requested disconnect');\n      }\n      break;\n    default:\n      console.warn(`[Worker] Unknown message type from main thread: ${message.type}`);\n  }\n};\n\n// Start connection automatically\nconnectToWebSocket();","map":{"version":3,"names":["socket","reconnectAttempts","maxReconnectAttempts","reconnectInterval","activeSubscriptions","isConnected","connectToWebSocket","onclose","onerror","close","err","console","error","wsUrl","log","WebSocket","onopen","self","postMessage","type","length","subscribeToTokens","startPingInterval","event","code","reason","wasClean","stopPingInterval","handleReconnect","onmessage","message","JSON","parse","data","updates","delay","Math","pow","attempt","maxAttempts","setTimeout","pingInterval","setInterval","readyState","OPEN","send","stringify","clearInterval","tokens","warn","forEach","token","includes","push","subscriptions","unsubscribeFromTokens","filter"],"sources":["C:/Users/scr/OneDrive/Desktop/new/frontend/src/workers/websocketWorker.js"],"sourcesContent":["/* WebSocket Worker\n * This worker handles WebSocket connections independently from the main thread\n * Features:\n * - Auto reconnection on lost connections\n * - Connection status monitoring\n */\n\n/* eslint-disable no-restricted-globals */\n// Using 'self' is standard in web workers, disabling ESLint warning\n\nlet socket = null;\nlet reconnectAttempts = 0;\nconst maxReconnectAttempts = 10;\nconst reconnectInterval = 2000; // 2 seconds\nlet activeSubscriptions = [];\nlet isConnected = false;\n\n// Connection management\nconst connectToWebSocket = () => {\n  // Make sure any existing connection is closed\n  if (socket) {\n    try {\n      socket.onclose = null; // Remove the onclose handler to prevent reconnection loops\n      socket.onerror = null; // Remove the error handler\n      socket.close();\n    } catch (err) {\n      console.error('[Worker] Error closing existing socket:', err);\n    }\n  }\n\n  // Use a hardcoded URL to ensure we connect correctly\n  const wsUrl = 'ws://localhost:5000';\n  \n  console.log(`[Worker] Connecting to WebSocket at ${wsUrl}`);\n  \n  try {\n    socket = new WebSocket(wsUrl);\n    \n    socket.onopen = () => {\n      console.log('[Worker] WebSocket connection established');\n      isConnected = true;\n      reconnectAttempts = 0;\n      self.postMessage({ type: 'CONNECTION_STATUS', isConnected: true });\n      \n      // Resubscribe to tokens after reconnection\n      if (activeSubscriptions.length > 0) {\n        subscribeToTokens(activeSubscriptions);\n      }\n      \n      // Start sending periodic pings\n      startPingInterval();\n    };\n    \n    socket.onclose = (event) => {\n      console.log(`[Worker] WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason || 'No reason provided'}, Clean: ${event.wasClean}`);\n      isConnected = false;\n      stopPingInterval();\n      \n      self.postMessage({ type: 'CONNECTION_STATUS', isConnected: false });\n      \n      // Only try to reconnect if it wasn't a clean close\n      if (!event.wasClean) {\n        handleReconnect();\n      }\n    };\n    \n    socket.onerror = (error) => {\n      console.error('[Worker] WebSocket error:', error);\n      self.postMessage({ \n        type: 'ERROR', \n        error: 'Connection error. Attempting to reconnect...' \n      });\n    };\n    \n    socket.onmessage = (event) => {\n      try {\n        const message = JSON.parse(event.data);\n        \n        switch (message.type) {\n          case 'INITIAL_DATA':\n            self.postMessage({ type: 'INITIAL_DATA', data: message.data });\n            break;\n            \n          case 'PRICE_UPDATE':\n            // Handle price updates from server\n            self.postMessage({ \n              type: 'PRICE_UPDATE', \n              updates: message.updates \n            });\n            break;\n            \n          case 'PONG':\n            // Received pong from the server - connection is active\n            break;\n            \n          default:\n            console.log(`[Worker] Unknown message type: ${message.type}`);\n        }\n      } catch (error) {\n        console.error('[Worker] Error processing message:', error);\n      }\n    };\n  } catch (error) {\n    console.error('[Worker] Error creating WebSocket:', error);\n    isConnected = false;\n    handleReconnect();\n  }\n};\n\n// Handle reconnection with exponential backoff\nconst handleReconnect = () => {\n  if (reconnectAttempts >= maxReconnectAttempts) {\n    console.error('[Worker] Maximum reconnection attempts reached');\n    self.postMessage({ \n      type: 'ERROR',\n      error: 'Failed to reconnect after multiple attempts. Please refresh the page.'\n    });\n    return;\n  }\n  \n  const delay = reconnectInterval * Math.pow(1.5, reconnectAttempts);\n  reconnectAttempts++;\n  \n  self.postMessage({ \n    type: 'RECONNECTING',\n    attempt: reconnectAttempts, \n    maxAttempts: maxReconnectAttempts\n  });\n  \n  console.log(`[Worker] Reconnecting in ${delay}ms (attempt ${reconnectAttempts}/${maxReconnectAttempts})`);\n  \n  setTimeout(connectToWebSocket, delay);\n};\n\n// Keep-alive mechanism\nlet pingInterval = null;\n\nconst startPingInterval = () => {\n  stopPingInterval(); // Clear any existing interval\n  \n  pingInterval = setInterval(() => {\n    if (socket && socket.readyState === WebSocket.OPEN) {\n      socket.send(JSON.stringify({ type: 'PING' }));\n    }\n  }, 30000); // Send ping every 30 seconds\n};\n\nconst stopPingInterval = () => {\n  if (pingInterval) {\n    clearInterval(pingInterval);\n    pingInterval = null;\n  }\n};\n\n// Token subscription management\nconst subscribeToTokens = (tokens) => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.warn('[Worker] Cannot subscribe, socket not open');\n    // Save for later when connected\n    tokens.forEach(token => {\n      if (!activeSubscriptions.includes(token)) {\n        activeSubscriptions.push(token);\n      }\n    });\n    return;\n  }\n  \n  // Add to active subscriptions\n  tokens.forEach(token => {\n    if (!activeSubscriptions.includes(token)) {\n      activeSubscriptions.push(token);\n    }\n  });\n  \n  // Send subscription message\n  socket.send(JSON.stringify({\n    type: 'SUBSCRIBE',\n    tokens: tokens\n  }));\n  \n  // Notify the main thread\n  self.postMessage({\n    type: 'SUBSCRIPTION_UPDATE',\n    subscriptions: activeSubscriptions\n  });\n};\n\nconst unsubscribeFromTokens = (tokens) => {\n  // Remove from active subscriptions\n  activeSubscriptions = activeSubscriptions.filter(\n    token => !tokens.includes(token)\n  );\n  \n  if (socket && socket.readyState === WebSocket.OPEN) {\n    // Send unsubscription message\n    socket.send(JSON.stringify({\n      type: 'UNSUBSCRIBE',\n      tokens: tokens\n    }));\n  }\n  \n  // Notify the main thread\n  self.postMessage({\n    type: 'SUBSCRIPTION_UPDATE',\n    subscriptions: activeSubscriptions\n  });\n};\n\n// Handle messages from the main thread\nself.onmessage = (event) => {\n  const message = event.data;\n  \n  switch (message.type) {\n    case 'SUBSCRIBE':\n      subscribeToTokens(message.tokens);\n      break;\n      \n    case 'UNSUBSCRIBE':\n      unsubscribeFromTokens(message.tokens);\n      break;\n      \n    case 'GET_CONNECTION_STATUS':\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        isConnected: isConnected\n      });\n      break;\n      \n    case 'DISCONNECT':\n      if (socket) {\n        socket.close(1000, 'User requested disconnect');\n      }\n      break;\n      \n    default:\n      console.warn(`[Worker] Unknown message type from main thread: ${message.type}`);\n  }\n};\n\n// Start connection automatically\nconnectToWebSocket();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}