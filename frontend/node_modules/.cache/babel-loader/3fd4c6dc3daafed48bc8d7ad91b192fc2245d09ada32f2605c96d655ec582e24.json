{"ast":null,"code":"/* eslint-disable no-restricted-globals */\n// WebSocket Worker\nlet socket = null;\nlet reconnectInterval = null;\nlet reconnectAttempts = 0;\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst BASE_RECONNECT_DELAY = 1000;\nconst connectionTimeoutMs = 5000; // 5 second timeout for initial connection\nlet cachedInitialData = null;\n\n// Connect to WebSocket server with timeout\nconst connectToWebSocket = () => {\n  try {\n    const wsUrl = 'ws://localhost:5000';\n    console.log(`[Worker] Connecting to WebSocket at ${wsUrl}`);\n\n    // Close any existing socket\n    if (socket) {\n      socket.close();\n    }\n\n    // Set connection timeout\n    const connectionTimeout = setTimeout(() => {\n      if (socket && socket.readyState !== WebSocket.OPEN) {\n        console.log('[Worker] Connection timeout, attempting reconnect');\n        socket.close();\n        attemptReconnect();\n      }\n    }, connectionTimeoutMs);\n    socket = new WebSocket(wsUrl);\n    socket.onopen = () => {\n      console.log('[Worker] WebSocket connection established');\n      clearTimeout(connectionTimeout);\n      // Reset reconnect attempts on successful connection\n      reconnectAttempts = 0;\n      // Clear any pending reconnect interval\n      if (reconnectInterval) {\n        clearInterval(reconnectInterval);\n        reconnectInterval = null;\n      }\n      // Immediately send INITIAL_DATA_REQUEST to speed up data loading\n      socket.send(JSON.stringify({\n        type: 'INITIAL_DATA_REQUEST'\n      }));\n      // Notify main thread of connection\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        status: 'CONNECTED'\n      });\n    };\n    socket.onmessage = event => {\n      try {\n        const message = JSON.parse(event.data);\n        handleMessage(message);\n      } catch (error) {\n        console.error('[Worker] Error parsing message:', error, 'Raw data:', event.data);\n      }\n    };\n    socket.onclose = event => {\n      console.log(`[Worker] WebSocket connection closed: ${event.code} ${event.reason}`);\n      clearTimeout(connectionTimeout);\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        status: 'DISCONNECTED'\n      });\n\n      // Attempt to reconnect if not closing cleanly\n      if (event.code !== 1000) {\n        attemptReconnect();\n      }\n    };\n    socket.onerror = error => {\n      console.error('[Worker] WebSocket error:', error);\n      clearTimeout(connectionTimeout);\n      self.postMessage({\n        type: 'ERROR',\n        error: 'Failed to connect to WebSocket server. Please check if the server is running.'\n      });\n    };\n  } catch (error) {\n    console.error('[Worker] Error connecting to WebSocket:', error);\n    self.postMessage({\n      type: 'ERROR',\n      error: 'Failed to connect to WebSocket server. Please check if the server is running.'\n    });\n\n    // Attempt to reconnect on error\n    attemptReconnect();\n  }\n};\n\n// Attempt to reconnect with exponential backoff\nconst attemptReconnect = () => {\n  if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n    console.log('[Worker] Maximum reconnect attempts reached, giving up');\n    self.postMessage({\n      type: 'ERROR',\n      error: 'Failed to reconnect to the server after multiple attempts. Please refresh the page.'\n    });\n    return;\n  }\n\n  // Clear any existing reconnect interval\n  if (reconnectInterval) {\n    clearInterval(reconnectInterval);\n  }\n\n  // Calculate delay with exponential backoff\n  const delay = BASE_RECONNECT_DELAY * Math.pow(2, reconnectAttempts);\n  console.log(`[Worker] Attempting to reconnect in ${delay}ms (attempt ${reconnectAttempts + 1}/${MAX_RECONNECT_ATTEMPTS})`);\n  self.postMessage({\n    type: 'RECONNECTING',\n    attempt: reconnectAttempts + 1,\n    maxAttempts: MAX_RECONNECT_ATTEMPTS\n  });\n  reconnectInterval = setTimeout(() => {\n    reconnectAttempts++;\n    connectToWebSocket();\n  }, delay);\n};\n\n// Handle incoming WebSocket messages\nconst handleMessage = message => {\n  switch (message.type) {\n    case 'INITIAL_DATA':\n      console.log('[Worker] Received initial data');\n      // Cache the initial data for future requests\n      cachedInitialData = message.data;\n      self.postMessage({\n        type: 'INITIAL_DATA',\n        data: message.data\n      });\n      break;\n    case 'PRICE_UPDATE':\n      // Forward price updates directly to main thread\n      self.postMessage({\n        type: 'PRICE_UPDATE',\n        updates: message.updates\n      });\n      break;\n    case 'PONG':\n      // Just log pongs, no need to forward\n      console.log('[Worker] Received pong from server');\n      break;\n    default:\n      console.log(`[Worker] Received unknown message type: ${message.type}`, message);\n  }\n};\n\n// Subscribe to tokens\nconst subscribeToTokens = tokens => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.error('[Worker] Cannot subscribe, WebSocket not connected');\n    self.postMessage({\n      type: 'ERROR',\n      error: 'Cannot subscribe, WebSocket not connected. Trying to reconnect...'\n    });\n    connectToWebSocket();\n    return;\n  }\n  console.log(`[Worker] Subscribing to tokens: ${tokens.join(', ')}`);\n  socket.send(JSON.stringify({\n    type: 'SUBSCRIBE',\n    tokens\n  }));\n};\n\n// Unsubscribe from tokens\nconst unsubscribeFromTokens = tokens => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.error('[Worker] Cannot unsubscribe, WebSocket not connected');\n    return;\n  }\n  console.log(`[Worker] Unsubscribing from tokens: ${tokens.join(', ')}`);\n  socket.send(JSON.stringify({\n    type: 'UNSUBSCRIBE',\n    tokens\n  }));\n};\n\n// Send initial data from cache or request new data\nconst sendInitialData = () => {\n  if (cachedInitialData) {\n    // Send cached data immediately\n    self.postMessage({\n      type: 'INITIAL_DATA',\n      data: cachedInitialData\n    });\n  }\n\n  // Also request fresh data if connected\n  if (socket && socket.readyState === WebSocket.OPEN) {\n    socket.send(JSON.stringify({\n      type: 'INITIAL_DATA_REQUEST'\n    }));\n  }\n};\n\n// Send ping to keep connection alive\nconst ping = () => {\n  if (socket && socket.readyState === WebSocket.OPEN) {\n    socket.send(JSON.stringify({\n      type: 'PING'\n    }));\n  }\n};\n\n// Initialize ping interval\nconst startPingInterval = () => {\n  setInterval(ping, 30000); // Send ping every 30 seconds\n};\n\n// Handle messages from main thread\nself.onmessage = event => {\n  const message = event.data;\n  switch (message.type) {\n    case 'CONNECT':\n      connectToWebSocket();\n      startPingInterval();\n      break;\n    case 'SUBSCRIBE':\n      subscribeToTokens(message.tokens);\n      break;\n    case 'UNSUBSCRIBE':\n      unsubscribeFromTokens(message.tokens);\n      break;\n    case 'DISCONNECT':\n      if (socket) {\n        socket.close(1000, \"Normal closure\");\n      }\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        status: 'DISCONNECTED'\n      });\n      break;\n    case 'GET_CONNECTION_STATUS':\n      const status = socket && socket.readyState === WebSocket.OPEN ? 'CONNECTED' : 'DISCONNECTED';\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        status\n      });\n      break;\n    case 'GET_INITIAL_DATA':\n      sendInitialData();\n      break;\n    default:\n      console.log(`[Worker] Received unknown message from main thread: ${message.type}`);\n  }\n};\n\n// Initialize with disconnected status and connect immediately to reduce load time\nself.postMessage({\n  type: 'CONNECTION_STATUS',\n  status: 'DISCONNECTED'\n});\nconnectToWebSocket();","map":{"version":3,"names":["socket","reconnectInterval","reconnectAttempts","MAX_RECONNECT_ATTEMPTS","BASE_RECONNECT_DELAY","connectionTimeoutMs","cachedInitialData","connectToWebSocket","wsUrl","console","log","close","connectionTimeout","setTimeout","readyState","WebSocket","OPEN","attemptReconnect","onopen","clearTimeout","clearInterval","send","JSON","stringify","type","self","postMessage","status","onmessage","event","message","parse","data","handleMessage","error","onclose","code","reason","onerror","delay","Math","pow","attempt","maxAttempts","updates","subscribeToTokens","tokens","join","unsubscribeFromTokens","sendInitialData","ping","startPingInterval","setInterval"],"sources":["C:/Users/scr/OneDrive/Desktop/new/frontend/src/workers/websocketWorker.js"],"sourcesContent":["/* eslint-disable no-restricted-globals */\n// WebSocket Worker\nlet socket = null;\nlet reconnectInterval = null;\nlet reconnectAttempts = 0;\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst BASE_RECONNECT_DELAY = 1000;\nconst connectionTimeoutMs = 5000; // 5 second timeout for initial connection\nlet cachedInitialData = null;\n\n// Connect to WebSocket server with timeout\nconst connectToWebSocket = () => {\n  try {\n    const wsUrl = 'ws://localhost:5000';\n    console.log(`[Worker] Connecting to WebSocket at ${wsUrl}`);\n    \n    // Close any existing socket\n    if (socket) {\n      socket.close();\n    }\n    \n    // Set connection timeout\n    const connectionTimeout = setTimeout(() => {\n      if (socket && socket.readyState !== WebSocket.OPEN) {\n        console.log('[Worker] Connection timeout, attempting reconnect');\n        socket.close();\n        attemptReconnect();\n      }\n    }, connectionTimeoutMs);\n    \n    socket = new WebSocket(wsUrl);\n    \n    socket.onopen = () => {\n      console.log('[Worker] WebSocket connection established');\n      clearTimeout(connectionTimeout);\n      // Reset reconnect attempts on successful connection\n      reconnectAttempts = 0;\n      // Clear any pending reconnect interval\n      if (reconnectInterval) {\n        clearInterval(reconnectInterval);\n        reconnectInterval = null;\n      }\n      // Immediately send INITIAL_DATA_REQUEST to speed up data loading\n      socket.send(JSON.stringify({ type: 'INITIAL_DATA_REQUEST' }));\n      // Notify main thread of connection\n      self.postMessage({ type: 'CONNECTION_STATUS', status: 'CONNECTED' });\n    };\n    \n    socket.onmessage = (event) => {\n      try {\n        const message = JSON.parse(event.data);\n        handleMessage(message);\n      } catch (error) {\n        console.error('[Worker] Error parsing message:', error, 'Raw data:', event.data);\n      }\n    };\n    \n    socket.onclose = (event) => {\n      console.log(`[Worker] WebSocket connection closed: ${event.code} ${event.reason}`);\n      clearTimeout(connectionTimeout);\n      self.postMessage({ type: 'CONNECTION_STATUS', status: 'DISCONNECTED' });\n      \n      // Attempt to reconnect if not closing cleanly\n      if (event.code !== 1000) {\n        attemptReconnect();\n      }\n    };\n    \n    socket.onerror = (error) => {\n      console.error('[Worker] WebSocket error:', error);\n      clearTimeout(connectionTimeout);\n      self.postMessage({ \n        type: 'ERROR', \n        error: 'Failed to connect to WebSocket server. Please check if the server is running.'\n      });\n    };\n  } catch (error) {\n    console.error('[Worker] Error connecting to WebSocket:', error);\n    self.postMessage({ \n      type: 'ERROR', \n      error: 'Failed to connect to WebSocket server. Please check if the server is running.'\n    });\n    \n    // Attempt to reconnect on error\n    attemptReconnect();\n  }\n};\n\n// Attempt to reconnect with exponential backoff\nconst attemptReconnect = () => {\n  if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n    console.log('[Worker] Maximum reconnect attempts reached, giving up');\n    self.postMessage({ \n      type: 'ERROR', \n      error: 'Failed to reconnect to the server after multiple attempts. Please refresh the page.'\n    });\n    return;\n  }\n  \n  // Clear any existing reconnect interval\n  if (reconnectInterval) {\n    clearInterval(reconnectInterval);\n  }\n  \n  // Calculate delay with exponential backoff\n  const delay = BASE_RECONNECT_DELAY * Math.pow(2, reconnectAttempts);\n  console.log(`[Worker] Attempting to reconnect in ${delay}ms (attempt ${reconnectAttempts + 1}/${MAX_RECONNECT_ATTEMPTS})`);\n  \n  self.postMessage({\n    type: 'RECONNECTING',\n    attempt: reconnectAttempts + 1,\n    maxAttempts: MAX_RECONNECT_ATTEMPTS\n  });\n  \n  reconnectInterval = setTimeout(() => {\n    reconnectAttempts++;\n    connectToWebSocket();\n  }, delay);\n};\n\n// Handle incoming WebSocket messages\nconst handleMessage = (message) => {\n  switch (message.type) {\n    case 'INITIAL_DATA':\n      console.log('[Worker] Received initial data');\n      // Cache the initial data for future requests\n      cachedInitialData = message.data;\n      self.postMessage({\n        type: 'INITIAL_DATA',\n        data: message.data\n      });\n      break;\n      \n    case 'PRICE_UPDATE':\n      // Forward price updates directly to main thread\n      self.postMessage({\n        type: 'PRICE_UPDATE',\n        updates: message.updates\n      });\n      break;\n      \n    case 'PONG':\n      // Just log pongs, no need to forward\n      console.log('[Worker] Received pong from server');\n      break;\n      \n    default:\n      console.log(`[Worker] Received unknown message type: ${message.type}`, message);\n  }\n};\n\n// Subscribe to tokens\nconst subscribeToTokens = (tokens) => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.error('[Worker] Cannot subscribe, WebSocket not connected');\n    self.postMessage({ \n      type: 'ERROR', \n      error: 'Cannot subscribe, WebSocket not connected. Trying to reconnect...'\n    });\n    connectToWebSocket();\n    return;\n  }\n  \n  console.log(`[Worker] Subscribing to tokens: ${tokens.join(', ')}`);\n  \n  socket.send(JSON.stringify({\n    type: 'SUBSCRIBE',\n    tokens\n  }));\n};\n\n// Unsubscribe from tokens\nconst unsubscribeFromTokens = (tokens) => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.error('[Worker] Cannot unsubscribe, WebSocket not connected');\n    return;\n  }\n  \n  console.log(`[Worker] Unsubscribing from tokens: ${tokens.join(', ')}`);\n  \n  socket.send(JSON.stringify({\n    type: 'UNSUBSCRIBE',\n    tokens\n  }));\n};\n\n// Send initial data from cache or request new data\nconst sendInitialData = () => {\n  if (cachedInitialData) {\n    // Send cached data immediately\n    self.postMessage({\n      type: 'INITIAL_DATA',\n      data: cachedInitialData\n    });\n  }\n  \n  // Also request fresh data if connected\n  if (socket && socket.readyState === WebSocket.OPEN) {\n    socket.send(JSON.stringify({ type: 'INITIAL_DATA_REQUEST' }));\n  }\n};\n\n// Send ping to keep connection alive\nconst ping = () => {\n  if (socket && socket.readyState === WebSocket.OPEN) {\n    socket.send(JSON.stringify({ type: 'PING' }));\n  }\n};\n\n// Initialize ping interval\nconst startPingInterval = () => {\n  setInterval(ping, 30000); // Send ping every 30 seconds\n};\n\n// Handle messages from main thread\nself.onmessage = (event) => {\n  const message = event.data;\n  \n  switch (message.type) {\n    case 'CONNECT':\n      connectToWebSocket();\n      startPingInterval();\n      break;\n      \n    case 'SUBSCRIBE':\n      subscribeToTokens(message.tokens);\n      break;\n      \n    case 'UNSUBSCRIBE':\n      unsubscribeFromTokens(message.tokens);\n      break;\n      \n    case 'DISCONNECT':\n      if (socket) {\n        socket.close(1000, \"Normal closure\");\n      }\n      self.postMessage({ type: 'CONNECTION_STATUS', status: 'DISCONNECTED' });\n      break;\n      \n    case 'GET_CONNECTION_STATUS':\n      const status = socket && socket.readyState === WebSocket.OPEN ? 'CONNECTED' : 'DISCONNECTED';\n      self.postMessage({ type: 'CONNECTION_STATUS', status });\n      break;\n      \n    case 'GET_INITIAL_DATA':\n      sendInitialData();\n      break;\n      \n    default:\n      console.log(`[Worker] Received unknown message from main thread: ${message.type}`);\n  }\n};\n\n// Initialize with disconnected status and connect immediately to reduce load time\nself.postMessage({ type: 'CONNECTION_STATUS', status: 'DISCONNECTED' });\nconnectToWebSocket();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}