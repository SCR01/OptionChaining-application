{"ast":null,"code":"/* eslint-disable no-restricted-globals */\n// WebSocket Worker\nlet socket = null;\nlet reconnectInterval = null;\nlet reconnectAttempts = 0;\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst BASE_RECONNECT_DELAY = 1000;\nconst connectionTimeoutMs = 5000; // 5 second timeout for initial connection\nlet cachedInitialData = null;\nlet activeSubscriptions = []; // Track active subscriptions\n\n// Connect to WebSocket server with timeout\nconst connectToWebSocket = () => {\n  try {\n    const wsUrl = 'ws://localhost:5000';\n    console.log(`[Worker] Connecting to WebSocket at ${wsUrl}`);\n\n    // Close any existing socket\n    if (socket) {\n      socket.close();\n    }\n\n    // Set connection timeout\n    const connectionTimeout = setTimeout(() => {\n      if (socket && socket.readyState !== WebSocket.OPEN) {\n        console.log('[Worker] Connection timeout, attempting reconnect');\n        socket.close();\n        attemptReconnect();\n      }\n    }, connectionTimeoutMs);\n    socket = new WebSocket(wsUrl);\n    socket.onopen = () => {\n      console.log('[Worker] WebSocket connection established');\n      clearTimeout(connectionTimeout);\n      // Reset reconnect attempts on successful connection\n      reconnectAttempts = 0;\n      // Clear any pending reconnect interval\n      if (reconnectInterval) {\n        clearInterval(reconnectInterval);\n        reconnectInterval = null;\n      }\n      // Immediately send INITIAL_DATA_REQUEST to speed up data loading\n      socket.send(JSON.stringify({\n        type: 'INITIAL_DATA_REQUEST'\n      }));\n      // Notify main thread of connection\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        status: 'CONNECTED'\n      });\n\n      // Resubscribe to any tokens that were active before reconnection\n      if (activeSubscriptions.length > 0) {\n        console.log('[Worker] Resubscribing to active tokens:', activeSubscriptions);\n        socket.send(JSON.stringify({\n          type: 'SUBSCRIBE',\n          tokens: activeSubscriptions\n        }));\n        // Notify main thread of current subscriptions\n        self.postMessage({\n          type: 'SUBSCRIPTION_UPDATE',\n          subscriptions: [...activeSubscriptions]\n        });\n      }\n    };\n    socket.onmessage = event => {\n      try {\n        const message = JSON.parse(event.data);\n        handleMessage(message);\n      } catch (error) {\n        console.error('[Worker] Error parsing message:', error, 'Raw data:', event.data);\n      }\n    };\n    socket.onclose = event => {\n      console.log(`[Worker] WebSocket connection closed: ${event.code} ${event.reason}`);\n      clearTimeout(connectionTimeout);\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        status: 'DISCONNECTED'\n      });\n\n      // Attempt to reconnect if not closing cleanly\n      if (event.code !== 1000) {\n        attemptReconnect();\n      }\n    };\n    socket.onerror = error => {\n      console.error('[Worker] WebSocket error:', error);\n      clearTimeout(connectionTimeout);\n      self.postMessage({\n        type: 'ERROR',\n        error: 'Failed to connect to WebSocket server. Please check if the server is running.'\n      });\n    };\n  } catch (error) {\n    console.error('[Worker] Error connecting to WebSocket:', error);\n    self.postMessage({\n      type: 'ERROR',\n      error: 'Failed to connect to WebSocket server. Please check if the server is running.'\n    });\n\n    // Attempt to reconnect on error\n    attemptReconnect();\n  }\n};\n\n// Attempt to reconnect with exponential backoff\nconst attemptReconnect = () => {\n  if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n    console.log('[Worker] Maximum reconnect attempts reached, giving up');\n    self.postMessage({\n      type: 'ERROR',\n      error: 'Failed to reconnect to the server after multiple attempts. Please refresh the page.'\n    });\n    return;\n  }\n\n  // Clear any existing reconnect interval\n  if (reconnectInterval) {\n    clearInterval(reconnectInterval);\n  }\n\n  // Calculate delay with exponential backoff\n  const delay = BASE_RECONNECT_DELAY * Math.pow(2, reconnectAttempts);\n  console.log(`[Worker] Attempting to reconnect in ${delay}ms (attempt ${reconnectAttempts + 1}/${MAX_RECONNECT_ATTEMPTS})`);\n  self.postMessage({\n    type: 'RECONNECTING',\n    attempt: reconnectAttempts + 1,\n    maxAttempts: MAX_RECONNECT_ATTEMPTS\n  });\n  reconnectInterval = setTimeout(() => {\n    reconnectAttempts++;\n    connectToWebSocket();\n  }, delay);\n};\n\n// Handle incoming WebSocket messages\nconst handleMessage = message => {\n  switch (message.type) {\n    case 'INITIAL_DATA':\n      console.log('[Worker] Received initial data');\n      // Cache the initial data for future requests\n      cachedInitialData = message.data;\n      self.postMessage({\n        type: 'INITIAL_DATA',\n        data: message.data\n      });\n      break;\n    case 'PRICE_UPDATE':\n      // Forward price updates directly to main thread\n      self.postMessage({\n        type: 'PRICE_UPDATE',\n        updates: message.updates\n      });\n      break;\n    case 'PONG':\n      // Just log pongs, no need to forward\n      console.log('[Worker] Received pong from server');\n      break;\n    default:\n      console.log(`[Worker] Received unknown message type: ${message.type}`, message);\n  }\n};\n\n// Subscribe to tokens\nconst subscribeToTokens = tokens => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.error('[Worker] Cannot subscribe, WebSocket not connected');\n    self.postMessage({\n      type: 'ERROR',\n      error: 'Cannot subscribe, WebSocket not connected. Trying to reconnect...'\n    });\n    connectToWebSocket();\n    return;\n  }\n  console.log(`[Worker] Subscribing to tokens: ${tokens.join(', ')}`);\n\n  // Update our local active subscriptions\n  tokens.forEach(token => {\n    if (!activeSubscriptions.includes(token)) {\n      activeSubscriptions.push(token);\n    }\n  });\n  socket.send(JSON.stringify({\n    type: 'SUBSCRIBE',\n    tokens\n  }));\n\n  // Notify main thread of updated subscriptions\n  self.postMessage({\n    type: 'SUBSCRIPTION_UPDATE',\n    subscriptions: [...activeSubscriptions]\n  });\n};\n\n// Unsubscribe from tokens\nconst unsubscribeFromTokens = tokens => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.error('[Worker] Cannot unsubscribe, WebSocket not connected');\n    return;\n  }\n  console.log(`[Worker] Unsubscribing from tokens: ${tokens.join(', ')}`);\n\n  // Remove from our local active subscriptions\n  activeSubscriptions = activeSubscriptions.filter(token => !tokens.includes(token));\n  socket.send(JSON.stringify({\n    type: 'UNSUBSCRIBE',\n    tokens\n  }));\n\n  // Notify main thread of updated subscriptions\n  self.postMessage({\n    type: 'SUBSCRIPTION_UPDATE',\n    subscriptions: [...activeSubscriptions]\n  });\n};\n\n// Send initial data from cache or request new data\nconst sendInitialData = () => {\n  if (cachedInitialData) {\n    // Send cached data immediately\n    self.postMessage({\n      type: 'INITIAL_DATA',\n      data: cachedInitialData\n    });\n  }\n\n  // Also request fresh data if connected\n  if (socket && socket.readyState === WebSocket.OPEN) {\n    socket.send(JSON.stringify({\n      type: 'INITIAL_DATA_REQUEST'\n    }));\n  }\n\n  // Send current subscription status\n  self.postMessage({\n    type: 'SUBSCRIPTION_UPDATE',\n    subscriptions: [...activeSubscriptions]\n  });\n};\n\n// Send ping to keep connection alive\nconst ping = () => {\n  if (socket && socket.readyState === WebSocket.OPEN) {\n    socket.send(JSON.stringify({\n      type: 'PING'\n    }));\n  }\n};\n\n// Initialize ping interval\nconst startPingInterval = () => {\n  setInterval(ping, 30000); // Send ping every 30 seconds\n};\n\n// Handle messages from main thread\nself.onmessage = event => {\n  const message = event.data;\n  switch (message.type) {\n    case 'CONNECT':\n      connectToWebSocket();\n      startPingInterval();\n      break;\n    case 'SUBSCRIBE':\n      subscribeToTokens(message.tokens);\n      break;\n    case 'UNSUBSCRIBE':\n      unsubscribeFromTokens(message.tokens);\n      break;\n    case 'DISCONNECT':\n      if (socket) {\n        // Clear active subscriptions on explicit disconnect\n        activeSubscriptions = [];\n        socket.close(1000, \"Normal closure\");\n      }\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        status: 'DISCONNECTED'\n      });\n      self.postMessage({\n        type: 'SUBSCRIPTION_UPDATE',\n        subscriptions: []\n      });\n      break;\n    case 'GET_CONNECTION_STATUS':\n      const status = socket && socket.readyState === WebSocket.OPEN ? 'CONNECTED' : 'DISCONNECTED';\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        status\n      });\n      break;\n    case 'GET_INITIAL_DATA':\n      sendInitialData();\n      break;\n    default:\n      console.log(`[Worker] Received unknown message from main thread: ${message.type}`);\n  }\n};\n\n// Initialize with disconnected status and connect immediately to reduce load time\nself.postMessage({\n  type: 'CONNECTION_STATUS',\n  status: 'DISCONNECTED'\n});\nconnectToWebSocket();","map":{"version":3,"names":["socket","reconnectInterval","reconnectAttempts","MAX_RECONNECT_ATTEMPTS","BASE_RECONNECT_DELAY","connectionTimeoutMs","cachedInitialData","activeSubscriptions","connectToWebSocket","wsUrl","console","log","close","connectionTimeout","setTimeout","readyState","WebSocket","OPEN","attemptReconnect","onopen","clearTimeout","clearInterval","send","JSON","stringify","type","self","postMessage","status","length","tokens","subscriptions","onmessage","event","message","parse","data","handleMessage","error","onclose","code","reason","onerror","delay","Math","pow","attempt","maxAttempts","updates","subscribeToTokens","join","forEach","token","includes","push","unsubscribeFromTokens","filter","sendInitialData","ping","startPingInterval","setInterval"],"sources":["C:/Users/scr/OneDrive/Desktop/new/frontend/src/workers/websocketWorker.js"],"sourcesContent":["/* eslint-disable no-restricted-globals */\n// WebSocket Worker\nlet socket = null;\nlet reconnectInterval = null;\nlet reconnectAttempts = 0;\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst BASE_RECONNECT_DELAY = 1000;\nconst connectionTimeoutMs = 5000; // 5 second timeout for initial connection\nlet cachedInitialData = null;\nlet activeSubscriptions = []; // Track active subscriptions\n\n// Connect to WebSocket server with timeout\nconst connectToWebSocket = () => {\n  try {\n    const wsUrl = 'ws://localhost:5000';\n    console.log(`[Worker] Connecting to WebSocket at ${wsUrl}`);\n    \n    // Close any existing socket\n    if (socket) {\n      socket.close();\n    }\n    \n    // Set connection timeout\n    const connectionTimeout = setTimeout(() => {\n      if (socket && socket.readyState !== WebSocket.OPEN) {\n        console.log('[Worker] Connection timeout, attempting reconnect');\n        socket.close();\n        attemptReconnect();\n      }\n    }, connectionTimeoutMs);\n    \n    socket = new WebSocket(wsUrl);\n    \n    socket.onopen = () => {\n      console.log('[Worker] WebSocket connection established');\n      clearTimeout(connectionTimeout);\n      // Reset reconnect attempts on successful connection\n      reconnectAttempts = 0;\n      // Clear any pending reconnect interval\n      if (reconnectInterval) {\n        clearInterval(reconnectInterval);\n        reconnectInterval = null;\n      }\n      // Immediately send INITIAL_DATA_REQUEST to speed up data loading\n      socket.send(JSON.stringify({ type: 'INITIAL_DATA_REQUEST' }));\n      // Notify main thread of connection\n      self.postMessage({ type: 'CONNECTION_STATUS', status: 'CONNECTED' });\n      \n      // Resubscribe to any tokens that were active before reconnection\n      if (activeSubscriptions.length > 0) {\n        console.log('[Worker] Resubscribing to active tokens:', activeSubscriptions);\n        socket.send(JSON.stringify({\n          type: 'SUBSCRIBE',\n          tokens: activeSubscriptions\n        }));\n        // Notify main thread of current subscriptions\n        self.postMessage({\n          type: 'SUBSCRIPTION_UPDATE',\n          subscriptions: [...activeSubscriptions]\n        });\n      }\n    };\n    \n    socket.onmessage = (event) => {\n      try {\n        const message = JSON.parse(event.data);\n        handleMessage(message);\n      } catch (error) {\n        console.error('[Worker] Error parsing message:', error, 'Raw data:', event.data);\n      }\n    };\n    \n    socket.onclose = (event) => {\n      console.log(`[Worker] WebSocket connection closed: ${event.code} ${event.reason}`);\n      clearTimeout(connectionTimeout);\n      self.postMessage({ type: 'CONNECTION_STATUS', status: 'DISCONNECTED' });\n      \n      // Attempt to reconnect if not closing cleanly\n      if (event.code !== 1000) {\n        attemptReconnect();\n      }\n    };\n    \n    socket.onerror = (error) => {\n      console.error('[Worker] WebSocket error:', error);\n      clearTimeout(connectionTimeout);\n      self.postMessage({ \n        type: 'ERROR', \n        error: 'Failed to connect to WebSocket server. Please check if the server is running.'\n      });\n    };\n  } catch (error) {\n    console.error('[Worker] Error connecting to WebSocket:', error);\n    self.postMessage({ \n      type: 'ERROR', \n      error: 'Failed to connect to WebSocket server. Please check if the server is running.'\n    });\n    \n    // Attempt to reconnect on error\n    attemptReconnect();\n  }\n};\n\n// Attempt to reconnect with exponential backoff\nconst attemptReconnect = () => {\n  if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n    console.log('[Worker] Maximum reconnect attempts reached, giving up');\n    self.postMessage({ \n      type: 'ERROR', \n      error: 'Failed to reconnect to the server after multiple attempts. Please refresh the page.'\n    });\n    return;\n  }\n  \n  // Clear any existing reconnect interval\n  if (reconnectInterval) {\n    clearInterval(reconnectInterval);\n  }\n  \n  // Calculate delay with exponential backoff\n  const delay = BASE_RECONNECT_DELAY * Math.pow(2, reconnectAttempts);\n  console.log(`[Worker] Attempting to reconnect in ${delay}ms (attempt ${reconnectAttempts + 1}/${MAX_RECONNECT_ATTEMPTS})`);\n  \n  self.postMessage({\n    type: 'RECONNECTING',\n    attempt: reconnectAttempts + 1,\n    maxAttempts: MAX_RECONNECT_ATTEMPTS\n  });\n  \n  reconnectInterval = setTimeout(() => {\n    reconnectAttempts++;\n    connectToWebSocket();\n  }, delay);\n};\n\n// Handle incoming WebSocket messages\nconst handleMessage = (message) => {\n  switch (message.type) {\n    case 'INITIAL_DATA':\n      console.log('[Worker] Received initial data');\n      // Cache the initial data for future requests\n      cachedInitialData = message.data;\n      self.postMessage({\n        type: 'INITIAL_DATA',\n        data: message.data\n      });\n      break;\n      \n    case 'PRICE_UPDATE':\n      // Forward price updates directly to main thread\n      self.postMessage({\n        type: 'PRICE_UPDATE',\n        updates: message.updates\n      });\n      break;\n      \n    case 'PONG':\n      // Just log pongs, no need to forward\n      console.log('[Worker] Received pong from server');\n      break;\n      \n    default:\n      console.log(`[Worker] Received unknown message type: ${message.type}`, message);\n  }\n};\n\n// Subscribe to tokens\nconst subscribeToTokens = (tokens) => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.error('[Worker] Cannot subscribe, WebSocket not connected');\n    self.postMessage({ \n      type: 'ERROR', \n      error: 'Cannot subscribe, WebSocket not connected. Trying to reconnect...'\n    });\n    connectToWebSocket();\n    return;\n  }\n  \n  console.log(`[Worker] Subscribing to tokens: ${tokens.join(', ')}`);\n  \n  // Update our local active subscriptions\n  tokens.forEach(token => {\n    if (!activeSubscriptions.includes(token)) {\n      activeSubscriptions.push(token);\n    }\n  });\n  \n  socket.send(JSON.stringify({\n    type: 'SUBSCRIBE',\n    tokens\n  }));\n  \n  // Notify main thread of updated subscriptions\n  self.postMessage({\n    type: 'SUBSCRIPTION_UPDATE',\n    subscriptions: [...activeSubscriptions]\n  });\n};\n\n// Unsubscribe from tokens\nconst unsubscribeFromTokens = (tokens) => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.error('[Worker] Cannot unsubscribe, WebSocket not connected');\n    return;\n  }\n  \n  console.log(`[Worker] Unsubscribing from tokens: ${tokens.join(', ')}`);\n  \n  // Remove from our local active subscriptions\n  activeSubscriptions = activeSubscriptions.filter(token => !tokens.includes(token));\n  \n  socket.send(JSON.stringify({\n    type: 'UNSUBSCRIBE',\n    tokens\n  }));\n  \n  // Notify main thread of updated subscriptions\n  self.postMessage({\n    type: 'SUBSCRIPTION_UPDATE',\n    subscriptions: [...activeSubscriptions]\n  });\n};\n\n// Send initial data from cache or request new data\nconst sendInitialData = () => {\n  if (cachedInitialData) {\n    // Send cached data immediately\n    self.postMessage({\n      type: 'INITIAL_DATA',\n      data: cachedInitialData\n    });\n  }\n  \n  // Also request fresh data if connected\n  if (socket && socket.readyState === WebSocket.OPEN) {\n    socket.send(JSON.stringify({ type: 'INITIAL_DATA_REQUEST' }));\n  }\n  \n  // Send current subscription status\n  self.postMessage({\n    type: 'SUBSCRIPTION_UPDATE',\n    subscriptions: [...activeSubscriptions]\n  });\n};\n\n// Send ping to keep connection alive\nconst ping = () => {\n  if (socket && socket.readyState === WebSocket.OPEN) {\n    socket.send(JSON.stringify({ type: 'PING' }));\n  }\n};\n\n// Initialize ping interval\nconst startPingInterval = () => {\n  setInterval(ping, 30000); // Send ping every 30 seconds\n};\n\n// Handle messages from main thread\nself.onmessage = (event) => {\n  const message = event.data;\n  \n  switch (message.type) {\n    case 'CONNECT':\n      connectToWebSocket();\n      startPingInterval();\n      break;\n      \n    case 'SUBSCRIBE':\n      subscribeToTokens(message.tokens);\n      break;\n      \n    case 'UNSUBSCRIBE':\n      unsubscribeFromTokens(message.tokens);\n      break;\n      \n    case 'DISCONNECT':\n      if (socket) {\n        // Clear active subscriptions on explicit disconnect\n        activeSubscriptions = [];\n        socket.close(1000, \"Normal closure\");\n      }\n      self.postMessage({ \n        type: 'CONNECTION_STATUS', \n        status: 'DISCONNECTED' \n      });\n      self.postMessage({\n        type: 'SUBSCRIPTION_UPDATE',\n        subscriptions: []\n      });\n      break;\n      \n    case 'GET_CONNECTION_STATUS':\n      const status = socket && socket.readyState === WebSocket.OPEN ? 'CONNECTED' : 'DISCONNECTED';\n      self.postMessage({ type: 'CONNECTION_STATUS', status });\n      break;\n      \n    case 'GET_INITIAL_DATA':\n      sendInitialData();\n      break;\n      \n    default:\n      console.log(`[Worker] Received unknown message from main thread: ${message.type}`);\n  }\n};\n\n// Initialize with disconnected status and connect immediately to reduce load time\nself.postMessage({ type: 'CONNECTION_STATUS', status: 'DISCONNECTED' });\nconnectToWebSocket();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}