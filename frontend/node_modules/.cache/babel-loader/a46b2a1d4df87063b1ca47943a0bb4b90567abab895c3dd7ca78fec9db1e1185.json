{"ast":null,"code":"// WebSocket service using a Web Worker for improved performance\nlet worker = null;\nlet eventHandlers = {};\n\n// Initialize the worker\nconst initWorker = () => {\n  if (worker) return;\n\n  // Create the worker\n  worker = new Worker(new URL('../workers/websocketWorker.js', import.meta.url));\n\n  // Set up message listener\n  worker.onmessage = event => {\n    const message = event.data;\n    switch (message.type) {\n      case 'INITIAL_DATA':\n        if (eventHandlers.onInitialData) {\n          eventHandlers.onInitialData(message.data);\n        }\n        break;\n      case 'PRICE_UPDATE':\n        if (eventHandlers.onPriceUpdate) {\n          // Log update for debugging\n          console.log('Received price updates:', message.updates);\n          eventHandlers.onPriceUpdate(message.updates);\n        }\n        break;\n      case 'SUBSCRIPTION_UPDATE':\n        if (eventHandlers.onSubscriptionUpdate) {\n          console.log('Subscription updated:', message.subscriptions);\n          eventHandlers.onSubscriptionUpdate(message.subscriptions);\n        }\n        break;\n      case 'CONNECTION_STATUS':\n        if (eventHandlers.onConnectionStatus) {\n          console.log('Connection status updated:', message.status);\n          eventHandlers.onConnectionStatus(message.status === 'CONNECTED');\n        }\n        break;\n      case 'RECONNECTING':\n        if (eventHandlers.onReconnecting) {\n          eventHandlers.onReconnecting(message.attempt, message.maxAttempts);\n        }\n        break;\n      case 'ERROR':\n        if (eventHandlers.onError) {\n          eventHandlers.onError(message.error);\n        }\n        break;\n      default:\n        console.log('Unknown message type:', message.type);\n    }\n  };\n\n  // Handle worker errors\n  worker.onerror = error => {\n    console.error('WebSocket worker error:', error);\n    if (eventHandlers.onError) {\n      eventHandlers.onError(new Error('WebSocket worker error'));\n    }\n  };\n};\n\n// Connect to WebSocket and set up event handlers\nconst connectToWebSocket = handlers => {\n  eventHandlers = handlers || {};\n  initWorker();\n\n  // No need to send a message, the worker automatically connects on creation\n  // and reconnects on disconnection\n};\n\n// Subscribe to tokens\nconst subscribeToTokens = tokens => {\n  if (!worker) {\n    console.error('Worker not initialized. Cannot subscribe to tokens.');\n    return;\n  }\n  console.log('Subscribing to tokens:', tokens);\n  worker.postMessage({\n    type: 'SUBSCRIBE',\n    tokens: tokens\n  });\n};\n\n// Unsubscribe from tokens\nconst unsubscribeFromTokens = tokens => {\n  if (!worker) {\n    console.error('Worker not initialized. Cannot unsubscribe from tokens.');\n    return;\n  }\n  console.log('Unsubscribing from tokens:', tokens);\n  worker.postMessage({\n    type: 'UNSUBSCRIBE',\n    tokens: tokens\n  });\n};\n\n// Disconnect from WebSocket\nconst disconnect = () => {\n  if (!worker) return;\n  worker.postMessage({\n    type: 'DISCONNECT'\n  });\n};\n\n// Check connection status\nconst getConnectionStatus = () => {\n  if (!worker) return false;\n  worker.postMessage({\n    type: 'GET_CONNECTION_STATUS'\n  });\n};\nexport { connectToWebSocket, subscribeToTokens, unsubscribeFromTokens, disconnect, getConnectionStatus };","map":{"version":3,"names":["worker","eventHandlers","initWorker","Worker","URL","import","meta","url","onmessage","event","message","data","type","onInitialData","onPriceUpdate","console","log","updates","onSubscriptionUpdate","subscriptions","onConnectionStatus","status","onReconnecting","attempt","maxAttempts","onError","error","onerror","Error","connectToWebSocket","handlers","subscribeToTokens","tokens","postMessage","unsubscribeFromTokens","disconnect","getConnectionStatus"],"sources":["C:/Users/scr/OneDrive/Desktop/new/frontend/src/services/websocketService.js"],"sourcesContent":["// WebSocket service using a Web Worker for improved performance\nlet worker = null;\nlet eventHandlers = {};\n\n// Initialize the worker\nconst initWorker = () => {\n  if (worker) return;\n  \n  // Create the worker\n  worker = new Worker(new URL('../workers/websocketWorker.js', import.meta.url));\n  \n  // Set up message listener\n  worker.onmessage = (event) => {\n    const message = event.data;\n    \n    switch (message.type) {\n      case 'INITIAL_DATA':\n        if (eventHandlers.onInitialData) {\n          eventHandlers.onInitialData(message.data);\n        }\n        break;\n      case 'PRICE_UPDATE':\n        if (eventHandlers.onPriceUpdate) {\n          // Log update for debugging\n          console.log('Received price updates:', message.updates);\n          eventHandlers.onPriceUpdate(message.updates);\n        }\n        break;\n      case 'SUBSCRIPTION_UPDATE':\n        if (eventHandlers.onSubscriptionUpdate) {\n          console.log('Subscription updated:', message.subscriptions);\n          eventHandlers.onSubscriptionUpdate(message.subscriptions);\n        }\n        break;\n      case 'CONNECTION_STATUS':\n        if (eventHandlers.onConnectionStatus) {\n          console.log('Connection status updated:', message.status);\n          eventHandlers.onConnectionStatus(message.status === 'CONNECTED');\n        }\n        break;\n      case 'RECONNECTING':\n        if (eventHandlers.onReconnecting) {\n          eventHandlers.onReconnecting(message.attempt, message.maxAttempts);\n        }\n        break;\n      case 'ERROR':\n        if (eventHandlers.onError) {\n          eventHandlers.onError(message.error);\n        }\n        break;\n      default:\n        console.log('Unknown message type:', message.type);\n    }\n  };\n  \n  // Handle worker errors\n  worker.onerror = (error) => {\n    console.error('WebSocket worker error:', error);\n    if (eventHandlers.onError) {\n      eventHandlers.onError(new Error('WebSocket worker error'));\n    }\n  };\n};\n\n// Connect to WebSocket and set up event handlers\nconst connectToWebSocket = (handlers) => {\n  eventHandlers = handlers || {};\n  \n  initWorker();\n  \n  // No need to send a message, the worker automatically connects on creation\n  // and reconnects on disconnection\n};\n\n// Subscribe to tokens\nconst subscribeToTokens = (tokens) => {\n  if (!worker) {\n    console.error('Worker not initialized. Cannot subscribe to tokens.');\n    return;\n  }\n  \n  console.log('Subscribing to tokens:', tokens);\n  \n  worker.postMessage({\n    type: 'SUBSCRIBE',\n    tokens: tokens\n  });\n};\n\n// Unsubscribe from tokens\nconst unsubscribeFromTokens = (tokens) => {\n  if (!worker) {\n    console.error('Worker not initialized. Cannot unsubscribe from tokens.');\n    return;\n  }\n  \n  console.log('Unsubscribing from tokens:', tokens);\n  \n  worker.postMessage({\n    type: 'UNSUBSCRIBE',\n    tokens: tokens\n  });\n};\n\n// Disconnect from WebSocket\nconst disconnect = () => {\n  if (!worker) return;\n  \n  worker.postMessage({ type: 'DISCONNECT' });\n};\n\n// Check connection status\nconst getConnectionStatus = () => {\n  if (!worker) return false;\n  \n  worker.postMessage({ type: 'GET_CONNECTION_STATUS' });\n};\n\nexport {\n  connectToWebSocket,\n  subscribeToTokens,\n  unsubscribeFromTokens,\n  disconnect,\n  getConnectionStatus\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}