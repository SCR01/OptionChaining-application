{"ast":null,"code":"/* WebSocket Worker\n * This worker handles WebSocket connections independently from the main thread\n * Features:\n * - Auto reconnection on lost connections\n * - Bandwidth optimization through message batching\n * - Connection status monitoring\n */\n\n/* eslint-disable no-restricted-globals */\n// Using 'self' is standard in web workers, disabling ESLint warning\n\nlet socket = null;\nlet reconnectAttempts = 0;\nconst maxReconnectAttempts = 10;\nconst reconnectInterval = 2000; // 2 seconds\nlet activeSubscriptions = [];\nlet isConnected = false;\nlet pendingUpdates = {};\nlet pendingUpdateTimeout = null;\nconst updateThrottle = 150; // 150ms throttle for updates\n\n// Connection management\nconst connectToWebSocket = () => {\n  // Make sure any existing connection is closed\n  if (socket) {\n    try {\n      socket.onclose = null; // Remove the onclose handler to prevent reconnection loops\n      socket.onerror = null; // Remove the error handler\n      socket.close();\n    } catch (err) {\n      console.error('[Worker] Error closing existing socket:', err);\n    }\n  }\n\n  // Use a hardcoded URL to ensure we connect correctly\n  const wsUrl = 'ws://localhost:5000';\n  console.log(`[Worker] Connecting to WebSocket at ${wsUrl}`);\n  try {\n    socket = new WebSocket(wsUrl);\n    socket.onopen = () => {\n      console.log('[Worker] WebSocket connection established');\n      isConnected = true;\n      reconnectAttempts = 0;\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        isConnected: true\n      });\n\n      // Resubscribe to tokens after reconnection\n      if (activeSubscriptions.length > 0) {\n        subscribeToTokens(activeSubscriptions);\n      }\n\n      // Start sending periodic pings\n      startPingInterval();\n    };\n    socket.onclose = event => {\n      console.log(`[Worker] WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason || 'No reason provided'}, Clean: ${event.wasClean}`);\n      isConnected = false;\n      stopPingInterval();\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        isConnected: false\n      });\n\n      // Only try to reconnect if it wasn't a clean close\n      if (!event.wasClean) {\n        handleReconnect();\n      }\n    };\n    socket.onerror = error => {\n      console.error('[Worker] WebSocket error:', error);\n      self.postMessage({\n        type: 'ERROR',\n        error: 'Connection error. Attempting to reconnect...'\n      });\n    };\n    socket.onmessage = event => {\n      try {\n        const message = JSON.parse(event.data);\n        switch (message.type) {\n          case 'INITIAL_DATA':\n            self.postMessage({\n              type: 'INITIAL_DATA',\n              data: message.data\n            });\n            break;\n          case 'PRICE_UPDATE':\n            batchPriceUpdates(message.updates);\n            break;\n          case 'PONG':\n            // Received pong from the server - connection is active\n            break;\n          default:\n            console.log(`[Worker] Unknown message type: ${message.type}`);\n        }\n      } catch (error) {\n        console.error('[Worker] Error processing message:', error);\n      }\n    };\n  } catch (error) {\n    console.error('[Worker] Error creating WebSocket:', error);\n    isConnected = false;\n    handleReconnect();\n  }\n};\n\n// Batch price updates to reduce UI updates frequency\nconst batchPriceUpdates = updates => {\n  // Add new updates to pending updates\n  Object.entries(updates).forEach(([token, data]) => {\n    pendingUpdates[token] = data;\n  });\n\n  // If we already have a timeout scheduled, don't schedule another one\n  if (!pendingUpdateTimeout) {\n    pendingUpdateTimeout = setTimeout(() => {\n      if (Object.keys(pendingUpdates).length > 0) {\n        self.postMessage({\n          type: 'PRICE_UPDATE',\n          data: {\n            ...pendingUpdates\n          },\n          timestamp: Date.now()\n        });\n        pendingUpdates = {}; // Clear after sending\n      }\n      pendingUpdateTimeout = null;\n    }, updateThrottle);\n  }\n};\nconst handleReconnect = () => {\n  if (reconnectAttempts >= maxReconnectAttempts) {\n    console.error('[Worker] Max reconnect attempts reached');\n    self.postMessage({\n      type: 'ERROR',\n      error: 'Failed to reconnect after multiple attempts'\n    });\n    return;\n  }\n  reconnectAttempts++;\n  self.postMessage({\n    type: 'RECONNECTING',\n    attempt: reconnectAttempts,\n    maxAttempts: maxReconnectAttempts\n  });\n  setTimeout(() => {\n    connectToWebSocket();\n  }, reconnectInterval * Math.min(reconnectAttempts, 5)); // Incremental backoff\n};\n\n// Keep-alive mechanism\nlet pingInterval = null;\nconst startPingInterval = () => {\n  pingInterval = setInterval(() => {\n    if (socket && socket.readyState === WebSocket.OPEN) {\n      socket.send(JSON.stringify({\n        type: 'PING'\n      }));\n    }\n  }, 20000); // Ping every 20 seconds\n};\nconst stopPingInterval = () => {\n  if (pingInterval) {\n    clearInterval(pingInterval);\n    pingInterval = null;\n  }\n};\n\n// Token subscription management\nconst subscribeToTokens = tokens => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.warn('[Worker] WebSocket not connected, cannot subscribe');\n    return;\n  }\n  socket.send(JSON.stringify({\n    type: 'SUBSCRIBE',\n    tokens: tokens\n  }));\n};\nconst unsubscribeFromTokens = tokens => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.warn('[Worker] WebSocket not connected, cannot unsubscribe');\n    return;\n  }\n  socket.send(JSON.stringify({\n    type: 'UNSUBSCRIBE',\n    tokens: tokens\n  }));\n};\n\n// Handle messages from the main thread\nself.onmessage = event => {\n  const message = event.data;\n  switch (message.type) {\n    case 'CONNECT':\n      connectToWebSocket();\n      break;\n    case 'DISCONNECT':\n      if (socket) {\n        socket.close();\n        socket = null;\n      }\n      break;\n    case 'SUBSCRIBE':\n      subscribeToTokens(message.tokens);\n      break;\n    case 'UNSUBSCRIBE':\n      unsubscribeFromTokens(message.tokens);\n      break;\n    case 'GET_STATUS':\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        isConnected: isConnected\n      });\n      break;\n    default:\n      console.warn(`[Worker] Unknown message type from main thread: ${message.type}`);\n  }\n};\n\n// Start connection automatically\nconnectToWebSocket();","map":{"version":3,"names":["socket","reconnectAttempts","maxReconnectAttempts","reconnectInterval","activeSubscriptions","isConnected","pendingUpdates","pendingUpdateTimeout","updateThrottle","connectToWebSocket","onclose","onerror","close","err","console","error","wsUrl","log","WebSocket","onopen","self","postMessage","type","length","subscribeToTokens","startPingInterval","event","code","reason","wasClean","stopPingInterval","handleReconnect","onmessage","message","JSON","parse","data","batchPriceUpdates","updates","Object","entries","forEach","token","setTimeout","keys","timestamp","Date","now","attempt","maxAttempts","Math","min","pingInterval","setInterval","readyState","OPEN","send","stringify","clearInterval","tokens","warn","unsubscribeFromTokens"],"sources":["C:/Users/scr/OneDrive/Desktop/new/frontend/src/workers/websocketWorker.js"],"sourcesContent":["/* WebSocket Worker\n * This worker handles WebSocket connections independently from the main thread\n * Features:\n * - Auto reconnection on lost connections\n * - Bandwidth optimization through message batching\n * - Connection status monitoring\n */\n\n/* eslint-disable no-restricted-globals */\n// Using 'self' is standard in web workers, disabling ESLint warning\n\nlet socket = null;\nlet reconnectAttempts = 0;\nconst maxReconnectAttempts = 10;\nconst reconnectInterval = 2000; // 2 seconds\nlet activeSubscriptions = [];\nlet isConnected = false;\nlet pendingUpdates = {};\nlet pendingUpdateTimeout = null;\nconst updateThrottle = 150; // 150ms throttle for updates\n\n// Connection management\nconst connectToWebSocket = () => {\n  // Make sure any existing connection is closed\n  if (socket) {\n    try {\n      socket.onclose = null; // Remove the onclose handler to prevent reconnection loops\n      socket.onerror = null; // Remove the error handler\n      socket.close();\n    } catch (err) {\n      console.error('[Worker] Error closing existing socket:', err);\n    }\n  }\n\n  // Use a hardcoded URL to ensure we connect correctly\n  const wsUrl = 'ws://localhost:5000';\n  \n  console.log(`[Worker] Connecting to WebSocket at ${wsUrl}`);\n  \n  try {\n    socket = new WebSocket(wsUrl);\n    \n    socket.onopen = () => {\n      console.log('[Worker] WebSocket connection established');\n      isConnected = true;\n      reconnectAttempts = 0;\n      self.postMessage({ type: 'CONNECTION_STATUS', isConnected: true });\n      \n      // Resubscribe to tokens after reconnection\n      if (activeSubscriptions.length > 0) {\n        subscribeToTokens(activeSubscriptions);\n      }\n      \n      // Start sending periodic pings\n      startPingInterval();\n    };\n    \n    socket.onclose = (event) => {\n      console.log(`[Worker] WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason || 'No reason provided'}, Clean: ${event.wasClean}`);\n      isConnected = false;\n      stopPingInterval();\n      \n      self.postMessage({ type: 'CONNECTION_STATUS', isConnected: false });\n      \n      // Only try to reconnect if it wasn't a clean close\n      if (!event.wasClean) {\n        handleReconnect();\n      }\n    };\n    \n    socket.onerror = (error) => {\n      console.error('[Worker] WebSocket error:', error);\n      self.postMessage({ \n        type: 'ERROR', \n        error: 'Connection error. Attempting to reconnect...' \n      });\n    };\n    \n    socket.onmessage = (event) => {\n      try {\n        const message = JSON.parse(event.data);\n        \n        switch (message.type) {\n          case 'INITIAL_DATA':\n            self.postMessage({ type: 'INITIAL_DATA', data: message.data });\n            break;\n            \n          case 'PRICE_UPDATE':\n            batchPriceUpdates(message.updates);\n            break;\n            \n          case 'PONG':\n            // Received pong from the server - connection is active\n            break;\n            \n          default:\n            console.log(`[Worker] Unknown message type: ${message.type}`);\n        }\n      } catch (error) {\n        console.error('[Worker] Error processing message:', error);\n      }\n    };\n  } catch (error) {\n    console.error('[Worker] Error creating WebSocket:', error);\n    isConnected = false;\n    handleReconnect();\n  }\n};\n\n// Batch price updates to reduce UI updates frequency\nconst batchPriceUpdates = (updates) => {\n  // Add new updates to pending updates\n  Object.entries(updates).forEach(([token, data]) => {\n    pendingUpdates[token] = data;\n  });\n  \n  // If we already have a timeout scheduled, don't schedule another one\n  if (!pendingUpdateTimeout) {\n    pendingUpdateTimeout = setTimeout(() => {\n      if (Object.keys(pendingUpdates).length > 0) {\n        self.postMessage({ \n          type: 'PRICE_UPDATE', \n          data: { ...pendingUpdates },\n          timestamp: Date.now()\n        });\n        pendingUpdates = {}; // Clear after sending\n      }\n      pendingUpdateTimeout = null;\n    }, updateThrottle);\n  }\n};\n\nconst handleReconnect = () => {\n  if (reconnectAttempts >= maxReconnectAttempts) {\n    console.error('[Worker] Max reconnect attempts reached');\n    self.postMessage({ \n      type: 'ERROR', \n      error: 'Failed to reconnect after multiple attempts' \n    });\n    return;\n  }\n\n  reconnectAttempts++;\n  \n  self.postMessage({ \n    type: 'RECONNECTING', \n    attempt: reconnectAttempts,\n    maxAttempts: maxReconnectAttempts\n  });\n  \n  setTimeout(() => {\n    connectToWebSocket();\n  }, reconnectInterval * Math.min(reconnectAttempts, 5)); // Incremental backoff\n};\n\n// Keep-alive mechanism\nlet pingInterval = null;\n\nconst startPingInterval = () => {\n  pingInterval = setInterval(() => {\n    if (socket && socket.readyState === WebSocket.OPEN) {\n      socket.send(JSON.stringify({ type: 'PING' }));\n    }\n  }, 20000); // Ping every 20 seconds\n};\n\nconst stopPingInterval = () => {\n  if (pingInterval) {\n    clearInterval(pingInterval);\n    pingInterval = null;\n  }\n};\n\n// Token subscription management\nconst subscribeToTokens = (tokens) => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.warn('[Worker] WebSocket not connected, cannot subscribe');\n    return;\n  }\n\n  socket.send(JSON.stringify({\n    type: 'SUBSCRIBE',\n    tokens: tokens\n  }));\n};\n\nconst unsubscribeFromTokens = (tokens) => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.warn('[Worker] WebSocket not connected, cannot unsubscribe');\n    return;\n  }\n\n  socket.send(JSON.stringify({\n    type: 'UNSUBSCRIBE',\n    tokens: tokens\n  }));\n};\n\n// Handle messages from the main thread\nself.onmessage = (event) => {\n  const message = event.data;\n  \n  switch (message.type) {\n    case 'CONNECT':\n      connectToWebSocket();\n      break;\n    case 'DISCONNECT':\n      if (socket) {\n        socket.close();\n        socket = null;\n      }\n      break;\n    case 'SUBSCRIBE':\n      subscribeToTokens(message.tokens);\n      break;\n    case 'UNSUBSCRIBE':\n      unsubscribeFromTokens(message.tokens);\n      break;\n    case 'GET_STATUS':\n      self.postMessage({ \n        type: 'CONNECTION_STATUS', \n        isConnected: isConnected \n      });\n      break;\n    default:\n      console.warn(`[Worker] Unknown message type from main thread: ${message.type}`);\n  }\n};\n\n// Start connection automatically\nconnectToWebSocket();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}