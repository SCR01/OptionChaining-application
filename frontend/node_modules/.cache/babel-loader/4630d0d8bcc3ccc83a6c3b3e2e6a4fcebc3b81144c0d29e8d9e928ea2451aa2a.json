{"ast":null,"code":"let socket = null;\nlet reconnectAttempts = 0;\nconst maxReconnectAttempts = 5;\nconst reconnectInterval = 3000;\nlet eventHandlers = {};\nlet activeSubscriptions = [];\n\n// WebSocket service with auto-reconnect functionality\nconst connectToWebSocket = handlers => {\n  eventHandlers = handlers;\n  if (socket) {\n    return;\n  }\n  const wsUrl = `ws://${window.location.hostname}:5000`;\n  socket = new WebSocket(wsUrl);\n  socket.onopen = () => {\n    console.log('WebSocket connection established');\n    reconnectAttempts = 0;\n\n    // Resubscribe to tokens after reconnection\n    if (activeSubscriptions.length > 0) {\n      subscribeToTokens(activeSubscriptions);\n    }\n\n    // Start sending periodic ping messages to keep the connection alive\n    startPingInterval();\n  };\n  socket.onmessage = event => {\n    try {\n      const message = JSON.parse(event.data);\n      switch (message.type) {\n        case 'INITIAL_DATA':\n          if (eventHandlers.onInitialData) {\n            eventHandlers.onInitialData(message.data);\n          }\n          break;\n        case 'PRICE_UPDATE':\n          if (eventHandlers.onPriceUpdate) {\n            eventHandlers.onPriceUpdate(message.data);\n          }\n          break;\n        case 'MARKET_STATE':\n          if (eventHandlers.onMarketState) {\n            eventHandlers.onMarketState(message.data);\n          }\n          break;\n        case 'SUBSCRIPTION_UPDATE':\n          if (eventHandlers.onSubscriptionUpdate) {\n            activeSubscriptions = message.subscriptions;\n            eventHandlers.onSubscriptionUpdate(message.subscriptions);\n          }\n          break;\n        case 'PONG':\n          // Received pong from server, connection is alive\n          break;\n        default:\n          console.warn(`Unknown message type: ${message.type}`);\n      }\n    } catch (error) {\n      console.error('Error parsing WebSocket message:', error);\n    }\n  };\n  socket.onclose = event => {\n    console.log(`WebSocket connection closed: ${event.code} ${event.reason}`);\n    stopPingInterval();\n    if (!event.wasClean) {\n      handleReconnect();\n    }\n  };\n  socket.onerror = error => {\n    console.error('WebSocket error:', error);\n    if (eventHandlers.onError) {\n      eventHandlers.onError(error);\n    }\n  };\n};\nconst handleReconnect = () => {\n  if (reconnectAttempts >= maxReconnectAttempts) {\n    console.error('Max reconnect attempts reached');\n    if (eventHandlers.onError) {\n      eventHandlers.onError(new Error('Failed to reconnect to server after multiple attempts'));\n    }\n    return;\n  }\n  reconnectAttempts++;\n  console.log(`Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);\n  setTimeout(() => {\n    socket = null;\n    connectToWebSocket(eventHandlers);\n  }, reconnectInterval);\n};\n\n// Keep-alive ping mechanism\nlet pingInterval = null;\nconst startPingInterval = () => {\n  pingInterval = setInterval(() => {\n    if (socket && socket.readyState === WebSocket.OPEN) {\n      socket.send(JSON.stringify({\n        type: 'PING'\n      }));\n    }\n  }, 20000); // Send ping every 20 seconds\n};\nconst stopPingInterval = () => {\n  if (pingInterval) {\n    clearInterval(pingInterval);\n    pingInterval = null;\n  }\n};\n\n// Token subscription management\nconst subscribeToTokens = tokens => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.warn('WebSocket not connected, cannot subscribe');\n    return;\n  }\n  socket.send(JSON.stringify({\n    type: 'SUBSCRIBE',\n    tokens: tokens\n  }));\n};\nconst unsubscribeFromTokens = tokens => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.warn('WebSocket not connected, cannot unsubscribe');\n    return;\n  }\n  socket.send(JSON.stringify({\n    type: 'UNSUBSCRIBE',\n    tokens: tokens\n  }));\n};\n\n// Cleanup function\nconst disconnect = () => {\n  stopPingInterval();\n  if (socket) {\n    socket.close();\n    socket = null;\n  }\n  activeSubscriptions = [];\n};\nexport { connectToWebSocket, subscribeToTokens, unsubscribeFromTokens, disconnect };","map":{"version":3,"names":["socket","reconnectAttempts","maxReconnectAttempts","reconnectInterval","eventHandlers","activeSubscriptions","connectToWebSocket","handlers","wsUrl","window","location","hostname","WebSocket","onopen","console","log","length","subscribeToTokens","startPingInterval","onmessage","event","message","JSON","parse","data","type","onInitialData","onPriceUpdate","onMarketState","onSubscriptionUpdate","subscriptions","warn","error","onclose","code","reason","stopPingInterval","wasClean","handleReconnect","onerror","onError","Error","setTimeout","pingInterval","setInterval","readyState","OPEN","send","stringify","clearInterval","tokens","unsubscribeFromTokens","disconnect","close"],"sources":["C:/Users/scr/OneDrive/Desktop/new/frontend/src/services/websocketService.js"],"sourcesContent":["let socket = null;\nlet reconnectAttempts = 0;\nconst maxReconnectAttempts = 5;\nconst reconnectInterval = 3000;\nlet eventHandlers = {};\nlet activeSubscriptions = [];\n\n// WebSocket service with auto-reconnect functionality\nconst connectToWebSocket = (handlers) => {\n  eventHandlers = handlers;\n\n  if (socket) {\n    return;\n  }\n\n  const wsUrl = `ws://${window.location.hostname}:5000`;\n  socket = new WebSocket(wsUrl);\n\n  socket.onopen = () => {\n    console.log('WebSocket connection established');\n    reconnectAttempts = 0;\n    \n    // Resubscribe to tokens after reconnection\n    if (activeSubscriptions.length > 0) {\n      subscribeToTokens(activeSubscriptions);\n    }\n    \n    // Start sending periodic ping messages to keep the connection alive\n    startPingInterval();\n  };\n\n  socket.onmessage = (event) => {\n    try {\n      const message = JSON.parse(event.data);\n      \n      switch (message.type) {\n        case 'INITIAL_DATA':\n          if (eventHandlers.onInitialData) {\n            eventHandlers.onInitialData(message.data);\n          }\n          break;\n        case 'PRICE_UPDATE':\n          if (eventHandlers.onPriceUpdate) {\n            eventHandlers.onPriceUpdate(message.data);\n          }\n          break;\n        case 'MARKET_STATE':\n          if (eventHandlers.onMarketState) {\n            eventHandlers.onMarketState(message.data);\n          }\n          break;\n        case 'SUBSCRIPTION_UPDATE':\n          if (eventHandlers.onSubscriptionUpdate) {\n            activeSubscriptions = message.subscriptions;\n            eventHandlers.onSubscriptionUpdate(message.subscriptions);\n          }\n          break;\n        case 'PONG':\n          // Received pong from server, connection is alive\n          break;\n        default:\n          console.warn(`Unknown message type: ${message.type}`);\n      }\n    } catch (error) {\n      console.error('Error parsing WebSocket message:', error);\n    }\n  };\n\n  socket.onclose = (event) => {\n    console.log(`WebSocket connection closed: ${event.code} ${event.reason}`);\n    stopPingInterval();\n    \n    if (!event.wasClean) {\n      handleReconnect();\n    }\n  };\n\n  socket.onerror = (error) => {\n    console.error('WebSocket error:', error);\n    if (eventHandlers.onError) {\n      eventHandlers.onError(error);\n    }\n  };\n};\n\nconst handleReconnect = () => {\n  if (reconnectAttempts >= maxReconnectAttempts) {\n    console.error('Max reconnect attempts reached');\n    if (eventHandlers.onError) {\n      eventHandlers.onError(new Error('Failed to reconnect to server after multiple attempts'));\n    }\n    return;\n  }\n\n  reconnectAttempts++;\n  console.log(`Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);\n  \n  setTimeout(() => {\n    socket = null;\n    connectToWebSocket(eventHandlers);\n  }, reconnectInterval);\n};\n\n// Keep-alive ping mechanism\nlet pingInterval = null;\n\nconst startPingInterval = () => {\n  pingInterval = setInterval(() => {\n    if (socket && socket.readyState === WebSocket.OPEN) {\n      socket.send(JSON.stringify({ type: 'PING' }));\n    }\n  }, 20000); // Send ping every 20 seconds\n};\n\nconst stopPingInterval = () => {\n  if (pingInterval) {\n    clearInterval(pingInterval);\n    pingInterval = null;\n  }\n};\n\n// Token subscription management\nconst subscribeToTokens = (tokens) => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.warn('WebSocket not connected, cannot subscribe');\n    return;\n  }\n\n  socket.send(JSON.stringify({\n    type: 'SUBSCRIBE',\n    tokens: tokens\n  }));\n};\n\nconst unsubscribeFromTokens = (tokens) => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.warn('WebSocket not connected, cannot unsubscribe');\n    return;\n  }\n\n  socket.send(JSON.stringify({\n    type: 'UNSUBSCRIBE',\n    tokens: tokens\n  }));\n};\n\n// Cleanup function\nconst disconnect = () => {\n  stopPingInterval();\n  \n  if (socket) {\n    socket.close();\n    socket = null;\n  }\n  \n  activeSubscriptions = [];\n};\n\nexport {\n  connectToWebSocket,\n  subscribeToTokens,\n  unsubscribeFromTokens,\n  disconnect\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}