{"ast":null,"code":"/* eslint-disable no-restricted-globals */\n// WebSocket Worker\nlet socket = null;\nlet reconnectInterval = null;\nlet reconnectAttempts = 0;\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst BASE_RECONNECT_DELAY = 500; // Reduced from 1000ms to 500ms for faster reconnection\nconst connectionTimeoutMs = 3000; // Reduced from 5000ms to 3000ms for faster timeout detection\nlet cachedInitialData = null;\nlet activeSubscriptions = []; // Track active subscriptions\nlet connectionStartTime = 0;\nlet wsUrl = 'ws://localhost:5000'; // Default URL, can be overridden by messages from main thread\n\n// Connect to WebSocket server with timeout\nconst connectToWebSocket = () => {\n  try {\n    connectionStartTime = Date.now();\n    console.log(`[Worker] Connecting to WebSocket at ${wsUrl} at ${connectionStartTime}`);\n\n    // Close any existing socket\n    if (socket) {\n      socket.close();\n    }\n\n    // Set connection timeout - shorter timeout for faster UI feedback\n    const connectionTimeout = setTimeout(() => {\n      if (socket && socket.readyState !== WebSocket.OPEN) {\n        console.log('[Worker] Connection timeout, attempting reconnect');\n        socket.close();\n        attemptReconnect();\n      }\n    }, connectionTimeoutMs);\n    socket = new WebSocket(wsUrl);\n    socket.onopen = () => {\n      const connectionTime = Date.now() - connectionStartTime;\n      console.log(`[Worker] WebSocket connection established in ${connectionTime}ms`);\n      clearTimeout(connectionTimeout);\n      // Reset reconnect attempts on successful connection\n      reconnectAttempts = 0;\n      // Clear any pending reconnect interval\n      if (reconnectInterval) {\n        clearInterval(reconnectInterval);\n        reconnectInterval = null;\n      }\n\n      // Immediately notify main thread of connection - do this first for UI responsiveness\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        status: 'CONNECTED'\n      });\n\n      // Then immediately send INITIAL_DATA_REQUEST to speed up data loading\n      socket.send(JSON.stringify({\n        type: 'INITIAL_DATA_REQUEST'\n      }));\n\n      // Resubscribe to any tokens that were active before reconnection\n      if (activeSubscriptions.length > 0) {\n        console.log('[Worker] Resubscribing to active tokens:', activeSubscriptions);\n        socket.send(JSON.stringify({\n          type: 'SUBSCRIBE',\n          tokens: activeSubscriptions\n        }));\n        // Notify main thread of current subscriptions\n        self.postMessage({\n          type: 'SUBSCRIPTION_UPDATE',\n          subscriptions: [...activeSubscriptions]\n        });\n      }\n    };\n    socket.onmessage = event => {\n      try {\n        const message = JSON.parse(event.data);\n        handleMessage(message);\n      } catch (error) {\n        console.error('[Worker] Error parsing message:', error, 'Raw data:', event.data);\n      }\n    };\n    socket.onclose = event => {\n      console.log(`[Worker] WebSocket connection closed: ${event.code} ${event.reason}`);\n      clearTimeout(connectionTimeout);\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        status: 'DISCONNECTED'\n      });\n\n      // Attempt to reconnect if not closing cleanly\n      if (event.code !== 1000) {\n        attemptReconnect();\n      }\n    };\n    socket.onerror = error => {\n      console.error('[Worker] WebSocket error:', error);\n      clearTimeout(connectionTimeout);\n      self.postMessage({\n        type: 'ERROR',\n        error: 'Failed to connect to WebSocket server. Please check if the server is running.'\n      });\n    };\n  } catch (error) {\n    console.error('[Worker] Error connecting to WebSocket:', error);\n    self.postMessage({\n      type: 'ERROR',\n      error: 'Failed to connect to WebSocket server. Please check if the server is running.'\n    });\n\n    // Attempt to reconnect on error\n    attemptReconnect();\n  }\n};\n\n// Attempt to reconnect with exponential backoff\nconst attemptReconnect = () => {\n  if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n    console.log('[Worker] Maximum reconnect attempts reached, giving up');\n    self.postMessage({\n      type: 'ERROR',\n      error: 'Failed to reconnect to the server after multiple attempts. Please refresh the page.'\n    });\n    return;\n  }\n\n  // Clear any existing reconnect interval\n  if (reconnectInterval) {\n    clearInterval(reconnectInterval);\n  }\n\n  // Calculate delay with exponential backoff\n  const delay = BASE_RECONNECT_DELAY * Math.pow(2, reconnectAttempts);\n  console.log(`[Worker] Attempting to reconnect in ${delay}ms (attempt ${reconnectAttempts + 1}/${MAX_RECONNECT_ATTEMPTS})`);\n  self.postMessage({\n    type: 'RECONNECTING',\n    attempt: reconnectAttempts + 1,\n    maxAttempts: MAX_RECONNECT_ATTEMPTS\n  });\n  reconnectInterval = setTimeout(() => {\n    reconnectAttempts++;\n    connectToWebSocket();\n  }, delay);\n};\n\n// Handle incoming WebSocket messages\nconst handleMessage = message => {\n  switch (message.type) {\n    case 'INITIAL_DATA':\n      console.log('[Worker] Received initial data');\n      // Cache the initial data for future requests\n      cachedInitialData = message.data;\n      self.postMessage({\n        type: 'INITIAL_DATA',\n        data: message.data\n      });\n      break;\n    case 'PRICE_UPDATE':\n      // Forward price updates directly to main thread\n      self.postMessage({\n        type: 'PRICE_UPDATE',\n        updates: message.updates\n      });\n      break;\n    case 'PONG':\n      // Just log pongs, no need to forward\n      console.log('[Worker] Received pong from server');\n      break;\n    default:\n      console.log(`[Worker] Received unknown message type: ${message.type}`, message);\n  }\n};\n\n// Subscribe to tokens\nconst subscribeToTokens = tokens => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.error('[Worker] Cannot subscribe, WebSocket not connected');\n    self.postMessage({\n      type: 'ERROR',\n      error: 'Cannot subscribe, WebSocket not connected. Trying to reconnect...'\n    });\n    connectToWebSocket();\n    return;\n  }\n  console.log(`[Worker] Subscribing to tokens: ${tokens.join(', ')}`);\n\n  // Update our local active subscriptions\n  tokens.forEach(token => {\n    if (!activeSubscriptions.includes(token)) {\n      activeSubscriptions.push(token);\n    }\n  });\n  socket.send(JSON.stringify({\n    type: 'SUBSCRIBE',\n    tokens\n  }));\n\n  // Notify main thread of updated subscriptions\n  self.postMessage({\n    type: 'SUBSCRIPTION_UPDATE',\n    subscriptions: [...activeSubscriptions]\n  });\n};\n\n// Unsubscribe from tokens\nconst unsubscribeFromTokens = tokens => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.error('[Worker] Cannot unsubscribe, WebSocket not connected');\n    return;\n  }\n  console.log(`[Worker] Unsubscribing from tokens: ${tokens.join(', ')}`);\n\n  // Remove from our local active subscriptions\n  activeSubscriptions = activeSubscriptions.filter(token => !tokens.includes(token));\n  socket.send(JSON.stringify({\n    type: 'UNSUBSCRIBE',\n    tokens\n  }));\n\n  // Notify main thread of updated subscriptions\n  self.postMessage({\n    type: 'SUBSCRIPTION_UPDATE',\n    subscriptions: [...activeSubscriptions]\n  });\n};\n\n// Send initial data from cache or request new data\nconst sendInitialData = () => {\n  if (cachedInitialData) {\n    // Send cached data immediately\n    self.postMessage({\n      type: 'INITIAL_DATA',\n      data: cachedInitialData\n    });\n  }\n\n  // Also request fresh data if connected\n  if (socket && socket.readyState === WebSocket.OPEN) {\n    socket.send(JSON.stringify({\n      type: 'INITIAL_DATA_REQUEST'\n    }));\n  }\n\n  // Send current subscription status\n  self.postMessage({\n    type: 'SUBSCRIPTION_UPDATE',\n    subscriptions: [...activeSubscriptions]\n  });\n};\n\n// Send ping to keep connection alive\nconst ping = () => {\n  if (socket && socket.readyState === WebSocket.OPEN) {\n    socket.send(JSON.stringify({\n      type: 'PING'\n    }));\n  }\n};\n\n// Initialize ping interval\nconst startPingInterval = () => {\n  setInterval(ping, 30000); // Send ping every 30 seconds\n};\n\n// Handle messages from main thread\nself.onmessage = event => {\n  const message = event.data;\n  switch (message.type) {\n    case 'CONNECT':\n      // Update URL if provided\n      if (message.url) {\n        wsUrl = message.url;\n        console.log(`[Worker] Using WebSocket URL: ${wsUrl}`);\n      }\n      connectToWebSocket();\n      startPingInterval();\n      break;\n    case 'SET_WS_URL':\n      wsUrl = message.wsUrl;\n      console.log(`[Worker] Updated WebSocket URL to ${wsUrl}`);\n      break;\n    case 'SUBSCRIBE':\n      subscribeToTokens(message.tokens);\n      break;\n    case 'UNSUBSCRIBE':\n      unsubscribeFromTokens(message.tokens);\n      break;\n    case 'DISCONNECT':\n      if (socket) {\n        // Clear active subscriptions on explicit disconnect\n        activeSubscriptions = [];\n        socket.close(1000, \"Normal closure\");\n      }\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        status: 'DISCONNECTED'\n      });\n      self.postMessage({\n        type: 'SUBSCRIPTION_UPDATE',\n        subscriptions: []\n      });\n      break;\n    case 'GET_CONNECTION_STATUS':\n      const status = socket && socket.readyState === WebSocket.OPEN ? 'CONNECTED' : 'DISCONNECTED';\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        status\n      });\n      break;\n    case 'GET_INITIAL_DATA':\n      sendInitialData();\n      break;\n    default:\n      console.log(`[Worker] Received unknown message from main thread: ${message.type}`);\n  }\n};\n\n// Initialize with disconnected status and connect immediately to reduce load time\nself.postMessage({\n  type: 'CONNECTION_STATUS',\n  status: 'DISCONNECTED'\n});\nconnectToWebSocket();","map":{"version":3,"names":["socket","reconnectInterval","reconnectAttempts","MAX_RECONNECT_ATTEMPTS","BASE_RECONNECT_DELAY","connectionTimeoutMs","cachedInitialData","activeSubscriptions","connectionStartTime","wsUrl","connectToWebSocket","Date","now","console","log","close","connectionTimeout","setTimeout","readyState","WebSocket","OPEN","attemptReconnect","onopen","connectionTime","clearTimeout","clearInterval","self","postMessage","type","status","send","JSON","stringify","length","tokens","subscriptions","onmessage","event","message","parse","data","handleMessage","error","onclose","code","reason","onerror","delay","Math","pow","attempt","maxAttempts","updates","subscribeToTokens","join","forEach","token","includes","push","unsubscribeFromTokens","filter","sendInitialData","ping","startPingInterval","setInterval","url"],"sources":["C:/Users/scr/OneDrive/Desktop/new/frontend/src/workers/websocketWorker.js"],"sourcesContent":["/* eslint-disable no-restricted-globals */\n// WebSocket Worker\nlet socket = null;\nlet reconnectInterval = null;\nlet reconnectAttempts = 0;\nconst MAX_RECONNECT_ATTEMPTS = 5;\nconst BASE_RECONNECT_DELAY = 500; // Reduced from 1000ms to 500ms for faster reconnection\nconst connectionTimeoutMs = 3000; // Reduced from 5000ms to 3000ms for faster timeout detection\nlet cachedInitialData = null;\nlet activeSubscriptions = []; // Track active subscriptions\nlet connectionStartTime = 0;\nlet wsUrl = 'ws://localhost:5000'; // Default URL, can be overridden by messages from main thread\n\n// Connect to WebSocket server with timeout\nconst connectToWebSocket = () => {\n  try {\n    connectionStartTime = Date.now();\n    console.log(`[Worker] Connecting to WebSocket at ${wsUrl} at ${connectionStartTime}`);\n    \n    // Close any existing socket\n    if (socket) {\n      socket.close();\n    }\n    \n    // Set connection timeout - shorter timeout for faster UI feedback\n    const connectionTimeout = setTimeout(() => {\n      if (socket && socket.readyState !== WebSocket.OPEN) {\n        console.log('[Worker] Connection timeout, attempting reconnect');\n        socket.close();\n        attemptReconnect();\n      }\n    }, connectionTimeoutMs);\n    \n    socket = new WebSocket(wsUrl);\n    \n    socket.onopen = () => {\n      const connectionTime = Date.now() - connectionStartTime;\n      console.log(`[Worker] WebSocket connection established in ${connectionTime}ms`);\n      clearTimeout(connectionTimeout);\n      // Reset reconnect attempts on successful connection\n      reconnectAttempts = 0;\n      // Clear any pending reconnect interval\n      if (reconnectInterval) {\n        clearInterval(reconnectInterval);\n        reconnectInterval = null;\n      }\n      \n      // Immediately notify main thread of connection - do this first for UI responsiveness\n      self.postMessage({ type: 'CONNECTION_STATUS', status: 'CONNECTED' });\n      \n      // Then immediately send INITIAL_DATA_REQUEST to speed up data loading\n      socket.send(JSON.stringify({ type: 'INITIAL_DATA_REQUEST' }));\n      \n      // Resubscribe to any tokens that were active before reconnection\n      if (activeSubscriptions.length > 0) {\n        console.log('[Worker] Resubscribing to active tokens:', activeSubscriptions);\n        socket.send(JSON.stringify({\n          type: 'SUBSCRIBE',\n          tokens: activeSubscriptions\n        }));\n        // Notify main thread of current subscriptions\n        self.postMessage({\n          type: 'SUBSCRIPTION_UPDATE',\n          subscriptions: [...activeSubscriptions]\n        });\n      }\n    };\n    \n    socket.onmessage = (event) => {\n      try {\n        const message = JSON.parse(event.data);\n        handleMessage(message);\n      } catch (error) {\n        console.error('[Worker] Error parsing message:', error, 'Raw data:', event.data);\n      }\n    };\n    \n    socket.onclose = (event) => {\n      console.log(`[Worker] WebSocket connection closed: ${event.code} ${event.reason}`);\n      clearTimeout(connectionTimeout);\n      self.postMessage({ type: 'CONNECTION_STATUS', status: 'DISCONNECTED' });\n      \n      // Attempt to reconnect if not closing cleanly\n      if (event.code !== 1000) {\n        attemptReconnect();\n      }\n    };\n    \n    socket.onerror = (error) => {\n      console.error('[Worker] WebSocket error:', error);\n      clearTimeout(connectionTimeout);\n      self.postMessage({ \n        type: 'ERROR', \n        error: 'Failed to connect to WebSocket server. Please check if the server is running.'\n      });\n    };\n  } catch (error) {\n    console.error('[Worker] Error connecting to WebSocket:', error);\n    self.postMessage({ \n      type: 'ERROR', \n      error: 'Failed to connect to WebSocket server. Please check if the server is running.'\n    });\n    \n    // Attempt to reconnect on error\n    attemptReconnect();\n  }\n};\n\n// Attempt to reconnect with exponential backoff\nconst attemptReconnect = () => {\n  if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {\n    console.log('[Worker] Maximum reconnect attempts reached, giving up');\n    self.postMessage({ \n      type: 'ERROR', \n      error: 'Failed to reconnect to the server after multiple attempts. Please refresh the page.'\n    });\n    return;\n  }\n  \n  // Clear any existing reconnect interval\n  if (reconnectInterval) {\n    clearInterval(reconnectInterval);\n  }\n  \n  // Calculate delay with exponential backoff\n  const delay = BASE_RECONNECT_DELAY * Math.pow(2, reconnectAttempts);\n  console.log(`[Worker] Attempting to reconnect in ${delay}ms (attempt ${reconnectAttempts + 1}/${MAX_RECONNECT_ATTEMPTS})`);\n  \n  self.postMessage({\n    type: 'RECONNECTING',\n    attempt: reconnectAttempts + 1,\n    maxAttempts: MAX_RECONNECT_ATTEMPTS\n  });\n  \n  reconnectInterval = setTimeout(() => {\n    reconnectAttempts++;\n    connectToWebSocket();\n  }, delay);\n};\n\n// Handle incoming WebSocket messages\nconst handleMessage = (message) => {\n  switch (message.type) {\n    case 'INITIAL_DATA':\n      console.log('[Worker] Received initial data');\n      // Cache the initial data for future requests\n      cachedInitialData = message.data;\n      self.postMessage({\n        type: 'INITIAL_DATA',\n        data: message.data\n      });\n      break;\n      \n    case 'PRICE_UPDATE':\n      // Forward price updates directly to main thread\n      self.postMessage({\n        type: 'PRICE_UPDATE',\n        updates: message.updates\n      });\n      break;\n      \n    case 'PONG':\n      // Just log pongs, no need to forward\n      console.log('[Worker] Received pong from server');\n      break;\n      \n    default:\n      console.log(`[Worker] Received unknown message type: ${message.type}`, message);\n  }\n};\n\n// Subscribe to tokens\nconst subscribeToTokens = (tokens) => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.error('[Worker] Cannot subscribe, WebSocket not connected');\n    self.postMessage({ \n      type: 'ERROR', \n      error: 'Cannot subscribe, WebSocket not connected. Trying to reconnect...'\n    });\n    connectToWebSocket();\n    return;\n  }\n  \n  console.log(`[Worker] Subscribing to tokens: ${tokens.join(', ')}`);\n  \n  // Update our local active subscriptions\n  tokens.forEach(token => {\n    if (!activeSubscriptions.includes(token)) {\n      activeSubscriptions.push(token);\n    }\n  });\n  \n  socket.send(JSON.stringify({\n    type: 'SUBSCRIBE',\n    tokens\n  }));\n  \n  // Notify main thread of updated subscriptions\n  self.postMessage({\n    type: 'SUBSCRIPTION_UPDATE',\n    subscriptions: [...activeSubscriptions]\n  });\n};\n\n// Unsubscribe from tokens\nconst unsubscribeFromTokens = (tokens) => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.error('[Worker] Cannot unsubscribe, WebSocket not connected');\n    return;\n  }\n  \n  console.log(`[Worker] Unsubscribing from tokens: ${tokens.join(', ')}`);\n  \n  // Remove from our local active subscriptions\n  activeSubscriptions = activeSubscriptions.filter(token => !tokens.includes(token));\n  \n  socket.send(JSON.stringify({\n    type: 'UNSUBSCRIBE',\n    tokens\n  }));\n  \n  // Notify main thread of updated subscriptions\n  self.postMessage({\n    type: 'SUBSCRIPTION_UPDATE',\n    subscriptions: [...activeSubscriptions]\n  });\n};\n\n// Send initial data from cache or request new data\nconst sendInitialData = () => {\n  if (cachedInitialData) {\n    // Send cached data immediately\n    self.postMessage({\n      type: 'INITIAL_DATA',\n      data: cachedInitialData\n    });\n  }\n  \n  // Also request fresh data if connected\n  if (socket && socket.readyState === WebSocket.OPEN) {\n    socket.send(JSON.stringify({ type: 'INITIAL_DATA_REQUEST' }));\n  }\n  \n  // Send current subscription status\n  self.postMessage({\n    type: 'SUBSCRIPTION_UPDATE',\n    subscriptions: [...activeSubscriptions]\n  });\n};\n\n// Send ping to keep connection alive\nconst ping = () => {\n  if (socket && socket.readyState === WebSocket.OPEN) {\n    socket.send(JSON.stringify({ type: 'PING' }));\n  }\n};\n\n// Initialize ping interval\nconst startPingInterval = () => {\n  setInterval(ping, 30000); // Send ping every 30 seconds\n};\n\n// Handle messages from main thread\nself.onmessage = (event) => {\n  const message = event.data;\n  \n  switch (message.type) {\n    case 'CONNECT':\n      // Update URL if provided\n      if (message.url) {\n        wsUrl = message.url;\n        console.log(`[Worker] Using WebSocket URL: ${wsUrl}`);\n      }\n      connectToWebSocket();\n      startPingInterval();\n      break;\n      \n    case 'SET_WS_URL':\n      wsUrl = message.wsUrl;\n      console.log(`[Worker] Updated WebSocket URL to ${wsUrl}`);\n      break;\n      \n    case 'SUBSCRIBE':\n      subscribeToTokens(message.tokens);\n      break;\n      \n    case 'UNSUBSCRIBE':\n      unsubscribeFromTokens(message.tokens);\n      break;\n      \n    case 'DISCONNECT':\n      if (socket) {\n        // Clear active subscriptions on explicit disconnect\n        activeSubscriptions = [];\n        socket.close(1000, \"Normal closure\");\n      }\n      self.postMessage({ \n        type: 'CONNECTION_STATUS', \n        status: 'DISCONNECTED' \n      });\n      self.postMessage({\n        type: 'SUBSCRIPTION_UPDATE',\n        subscriptions: []\n      });\n      break;\n      \n    case 'GET_CONNECTION_STATUS':\n      const status = socket && socket.readyState === WebSocket.OPEN ? 'CONNECTED' : 'DISCONNECTED';\n      self.postMessage({ type: 'CONNECTION_STATUS', status });\n      break;\n      \n    case 'GET_INITIAL_DATA':\n      sendInitialData();\n      break;\n      \n    default:\n      console.log(`[Worker] Received unknown message from main thread: ${message.type}`);\n  }\n};\n\n// Initialize with disconnected status and connect immediately to reduce load time\nself.postMessage({ type: 'CONNECTION_STATUS', status: 'DISCONNECTED' });\nconnectToWebSocket();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}