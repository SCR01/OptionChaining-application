{"ast":null,"code":"/* WebSocket Worker\n * This worker handles WebSocket connections independently from the main thread\n * Features:\n * - Auto reconnection on lost connections\n * - Bandwidth optimization through message batching\n * - Connection status monitoring\n */\n\n/* eslint-disable no-restricted-globals */\n// Using 'self' is standard in web workers, disabling ESLint warning\n\nlet socket = null;\nlet reconnectAttempts = 0;\nconst maxReconnectAttempts = 10;\nconst reconnectInterval = 2000; // 2 seconds\nlet activeSubscriptions = [];\nlet isConnected = false;\nlet pendingUpdates = {};\nlet pendingUpdateTimeout = null;\nconst updateThrottle = 150; // 150ms throttle for updates\n\n// Connection management\nconst connectToWebSocket = () => {\n  // Use a hardcoded URL to ensure we connect correctly\n  const wsUrl = 'ws://localhost:5000';\n  socket = new WebSocket(wsUrl);\n  socket.onopen = () => {\n    console.log('[Worker] WebSocket connection established');\n    isConnected = true;\n    reconnectAttempts = 0;\n    self.postMessage({\n      type: 'CONNECTION_STATUS',\n      isConnected: true\n    });\n\n    // Resubscribe to tokens after reconnection\n    if (activeSubscriptions.length > 0) {\n      subscribeToTokens(activeSubscriptions);\n    }\n\n    // Start sending periodic pings\n    startPingInterval();\n  };\n  socket.onmessage = event => {\n    try {\n      const message = JSON.parse(event.data);\n      switch (message.type) {\n        case 'INITIAL_DATA':\n          self.postMessage({\n            type: 'INITIAL_DATA',\n            data: message.data\n          });\n          break;\n        case 'PRICE_UPDATE':\n          // Add to pending updates to batch send updates to the main thread\n          batchPriceUpdates(message.data);\n          break;\n        case 'MARKET_STATE':\n          self.postMessage({\n            type: 'MARKET_STATE',\n            data: message.data\n          });\n          break;\n        case 'SUBSCRIPTION_UPDATE':\n          activeSubscriptions = message.subscriptions;\n          self.postMessage({\n            type: 'SUBSCRIPTION_UPDATE',\n            subscriptions: message.subscriptions\n          });\n          break;\n        case 'PONG':\n          // Received pong from server, connection is alive\n          break;\n        default:\n          console.warn(`[Worker] Unknown message type: ${message.type}`);\n      }\n    } catch (error) {\n      console.error('[Worker] Error parsing WebSocket message:', error);\n    }\n  };\n  socket.onclose = event => {\n    console.log(`[Worker] WebSocket connection closed: ${event.code} ${event.reason}`);\n    isConnected = false;\n    self.postMessage({\n      type: 'CONNECTION_STATUS',\n      isConnected: false\n    });\n    stopPingInterval();\n    if (!event.wasClean) {\n      handleReconnect();\n    }\n  };\n  socket.onerror = error => {\n    console.error('[Worker] WebSocket error:', error);\n    self.postMessage({\n      type: 'ERROR',\n      error: 'WebSocket connection error'\n    });\n  };\n};\n\n// Batch price updates to reduce UI updates frequency\nconst batchPriceUpdates = updates => {\n  // Add new updates to pending updates\n  Object.entries(updates).forEach(([token, data]) => {\n    pendingUpdates[token] = data;\n  });\n\n  // If we already have a timeout scheduled, don't schedule another one\n  if (!pendingUpdateTimeout) {\n    pendingUpdateTimeout = setTimeout(() => {\n      if (Object.keys(pendingUpdates).length > 0) {\n        self.postMessage({\n          type: 'PRICE_UPDATE',\n          data: {\n            ...pendingUpdates\n          },\n          timestamp: Date.now()\n        });\n        pendingUpdates = {}; // Clear after sending\n      }\n      pendingUpdateTimeout = null;\n    }, updateThrottle);\n  }\n};\nconst handleReconnect = () => {\n  if (reconnectAttempts >= maxReconnectAttempts) {\n    console.error('[Worker] Max reconnect attempts reached');\n    self.postMessage({\n      type: 'ERROR',\n      error: 'Failed to reconnect after multiple attempts'\n    });\n    return;\n  }\n  reconnectAttempts++;\n  self.postMessage({\n    type: 'RECONNECTING',\n    attempt: reconnectAttempts,\n    maxAttempts: maxReconnectAttempts\n  });\n  setTimeout(() => {\n    connectToWebSocket();\n  }, reconnectInterval * Math.min(reconnectAttempts, 5)); // Incremental backoff\n};\n\n// Keep-alive mechanism\nlet pingInterval = null;\nconst startPingInterval = () => {\n  pingInterval = setInterval(() => {\n    if (socket && socket.readyState === WebSocket.OPEN) {\n      socket.send(JSON.stringify({\n        type: 'PING'\n      }));\n    }\n  }, 20000); // Ping every 20 seconds\n};\nconst stopPingInterval = () => {\n  if (pingInterval) {\n    clearInterval(pingInterval);\n    pingInterval = null;\n  }\n};\n\n// Token subscription management\nconst subscribeToTokens = tokens => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.warn('[Worker] WebSocket not connected, cannot subscribe');\n    return;\n  }\n  socket.send(JSON.stringify({\n    type: 'SUBSCRIBE',\n    tokens: tokens\n  }));\n};\nconst unsubscribeFromTokens = tokens => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.warn('[Worker] WebSocket not connected, cannot unsubscribe');\n    return;\n  }\n  socket.send(JSON.stringify({\n    type: 'UNSUBSCRIBE',\n    tokens: tokens\n  }));\n};\n\n// Handle messages from the main thread\nself.onmessage = event => {\n  const message = event.data;\n  switch (message.type) {\n    case 'CONNECT':\n      connectToWebSocket();\n      break;\n    case 'DISCONNECT':\n      if (socket) {\n        socket.close();\n        socket = null;\n      }\n      break;\n    case 'SUBSCRIBE':\n      subscribeToTokens(message.tokens);\n      break;\n    case 'UNSUBSCRIBE':\n      unsubscribeFromTokens(message.tokens);\n      break;\n    case 'GET_STATUS':\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        isConnected: isConnected\n      });\n      break;\n    default:\n      console.warn(`[Worker] Unknown message type from main thread: ${message.type}`);\n  }\n};\n\n// Start connection automatically\nconnectToWebSocket();","map":{"version":3,"names":["socket","reconnectAttempts","maxReconnectAttempts","reconnectInterval","activeSubscriptions","isConnected","pendingUpdates","pendingUpdateTimeout","updateThrottle","connectToWebSocket","wsUrl","WebSocket","onopen","console","log","self","postMessage","type","length","subscribeToTokens","startPingInterval","onmessage","event","message","JSON","parse","data","batchPriceUpdates","subscriptions","warn","error","onclose","code","reason","stopPingInterval","wasClean","handleReconnect","onerror","updates","Object","entries","forEach","token","setTimeout","keys","timestamp","Date","now","attempt","maxAttempts","Math","min","pingInterval","setInterval","readyState","OPEN","send","stringify","clearInterval","tokens","unsubscribeFromTokens","close"],"sources":["C:/Users/scr/OneDrive/Desktop/new/frontend/src/workers/websocketWorker.js"],"sourcesContent":["/* WebSocket Worker\n * This worker handles WebSocket connections independently from the main thread\n * Features:\n * - Auto reconnection on lost connections\n * - Bandwidth optimization through message batching\n * - Connection status monitoring\n */\n\n/* eslint-disable no-restricted-globals */\n// Using 'self' is standard in web workers, disabling ESLint warning\n\nlet socket = null;\nlet reconnectAttempts = 0;\nconst maxReconnectAttempts = 10;\nconst reconnectInterval = 2000; // 2 seconds\nlet activeSubscriptions = [];\nlet isConnected = false;\nlet pendingUpdates = {};\nlet pendingUpdateTimeout = null;\nconst updateThrottle = 150; // 150ms throttle for updates\n\n// Connection management\nconst connectToWebSocket = () => {\n  // Use a hardcoded URL to ensure we connect correctly\n  const wsUrl = 'ws://localhost:5000';\n  \n  socket = new WebSocket(wsUrl);\n  \n  socket.onopen = () => {\n    console.log('[Worker] WebSocket connection established');\n    isConnected = true;\n    reconnectAttempts = 0;\n    self.postMessage({ type: 'CONNECTION_STATUS', isConnected: true });\n    \n    // Resubscribe to tokens after reconnection\n    if (activeSubscriptions.length > 0) {\n      subscribeToTokens(activeSubscriptions);\n    }\n    \n    // Start sending periodic pings\n    startPingInterval();\n  };\n\n  socket.onmessage = (event) => {\n    try {\n      const message = JSON.parse(event.data);\n      \n      switch (message.type) {\n        case 'INITIAL_DATA':\n          self.postMessage({ type: 'INITIAL_DATA', data: message.data });\n          break;\n        case 'PRICE_UPDATE':\n          // Add to pending updates to batch send updates to the main thread\n          batchPriceUpdates(message.data);\n          break;\n        case 'MARKET_STATE':\n          self.postMessage({ type: 'MARKET_STATE', data: message.data });\n          break;\n        case 'SUBSCRIPTION_UPDATE':\n          activeSubscriptions = message.subscriptions;\n          self.postMessage({ type: 'SUBSCRIPTION_UPDATE', subscriptions: message.subscriptions });\n          break;\n        case 'PONG':\n          // Received pong from server, connection is alive\n          break;\n        default:\n          console.warn(`[Worker] Unknown message type: ${message.type}`);\n      }\n    } catch (error) {\n      console.error('[Worker] Error parsing WebSocket message:', error);\n    }\n  };\n\n  socket.onclose = (event) => {\n    console.log(`[Worker] WebSocket connection closed: ${event.code} ${event.reason}`);\n    isConnected = false;\n    self.postMessage({ type: 'CONNECTION_STATUS', isConnected: false });\n    stopPingInterval();\n    \n    if (!event.wasClean) {\n      handleReconnect();\n    }\n  };\n\n  socket.onerror = (error) => {\n    console.error('[Worker] WebSocket error:', error);\n    self.postMessage({ type: 'ERROR', error: 'WebSocket connection error' });\n  };\n};\n\n// Batch price updates to reduce UI updates frequency\nconst batchPriceUpdates = (updates) => {\n  // Add new updates to pending updates\n  Object.entries(updates).forEach(([token, data]) => {\n    pendingUpdates[token] = data;\n  });\n  \n  // If we already have a timeout scheduled, don't schedule another one\n  if (!pendingUpdateTimeout) {\n    pendingUpdateTimeout = setTimeout(() => {\n      if (Object.keys(pendingUpdates).length > 0) {\n        self.postMessage({ \n          type: 'PRICE_UPDATE', \n          data: { ...pendingUpdates },\n          timestamp: Date.now()\n        });\n        pendingUpdates = {}; // Clear after sending\n      }\n      pendingUpdateTimeout = null;\n    }, updateThrottle);\n  }\n};\n\nconst handleReconnect = () => {\n  if (reconnectAttempts >= maxReconnectAttempts) {\n    console.error('[Worker] Max reconnect attempts reached');\n    self.postMessage({ \n      type: 'ERROR', \n      error: 'Failed to reconnect after multiple attempts' \n    });\n    return;\n  }\n\n  reconnectAttempts++;\n  \n  self.postMessage({ \n    type: 'RECONNECTING', \n    attempt: reconnectAttempts,\n    maxAttempts: maxReconnectAttempts\n  });\n  \n  setTimeout(() => {\n    connectToWebSocket();\n  }, reconnectInterval * Math.min(reconnectAttempts, 5)); // Incremental backoff\n};\n\n// Keep-alive mechanism\nlet pingInterval = null;\n\nconst startPingInterval = () => {\n  pingInterval = setInterval(() => {\n    if (socket && socket.readyState === WebSocket.OPEN) {\n      socket.send(JSON.stringify({ type: 'PING' }));\n    }\n  }, 20000); // Ping every 20 seconds\n};\n\nconst stopPingInterval = () => {\n  if (pingInterval) {\n    clearInterval(pingInterval);\n    pingInterval = null;\n  }\n};\n\n// Token subscription management\nconst subscribeToTokens = (tokens) => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.warn('[Worker] WebSocket not connected, cannot subscribe');\n    return;\n  }\n\n  socket.send(JSON.stringify({\n    type: 'SUBSCRIBE',\n    tokens: tokens\n  }));\n};\n\nconst unsubscribeFromTokens = (tokens) => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.warn('[Worker] WebSocket not connected, cannot unsubscribe');\n    return;\n  }\n\n  socket.send(JSON.stringify({\n    type: 'UNSUBSCRIBE',\n    tokens: tokens\n  }));\n};\n\n// Handle messages from the main thread\nself.onmessage = (event) => {\n  const message = event.data;\n  \n  switch (message.type) {\n    case 'CONNECT':\n      connectToWebSocket();\n      break;\n    case 'DISCONNECT':\n      if (socket) {\n        socket.close();\n        socket = null;\n      }\n      break;\n    case 'SUBSCRIBE':\n      subscribeToTokens(message.tokens);\n      break;\n    case 'UNSUBSCRIBE':\n      unsubscribeFromTokens(message.tokens);\n      break;\n    case 'GET_STATUS':\n      self.postMessage({ \n        type: 'CONNECTION_STATUS', \n        isConnected: isConnected \n      });\n      break;\n    default:\n      console.warn(`[Worker] Unknown message type from main thread: ${message.type}`);\n  }\n};\n\n// Start connection automatically\nconnectToWebSocket();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}