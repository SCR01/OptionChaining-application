{"ast":null,"code":"/* WebSocket Worker\n * This worker handles WebSocket connections independently from the main thread\n * Features:\n * - Auto reconnection on lost connections\n * - Bandwidth optimization through message batching\n * - Connection status monitoring\n */\n\n/* eslint-disable no-restricted-globals */\n// Using 'self' is standard in web workers, disabling ESLint warning\n\nlet socket = null;\nlet reconnectAttempts = 0;\nconst maxReconnectAttempts = 10;\nconst reconnectInterval = 2000; // 2 seconds\nlet activeSubscriptions = [];\nlet isConnected = false;\nlet pendingUpdates = {};\nlet pendingUpdateTimeout = null;\nconst updateThrottle = 150; // 150ms throttle for updates\n\n// Connection management\nconst connectToWebSocket = () => {\n  // Make sure any existing connection is closed\n  if (socket) {\n    try {\n      socket.onclose = null; // Remove the onclose handler to prevent reconnection loops\n      socket.onerror = null; // Remove the error handler\n      socket.close();\n    } catch (err) {\n      console.error('[Worker] Error closing existing socket:', err);\n    }\n  }\n\n  // Use a hardcoded URL to ensure we connect correctly\n  const wsUrl = 'ws://localhost:5000';\n  console.log(`[Worker] Connecting to WebSocket at ${wsUrl}`);\n  try {\n    socket = new WebSocket(wsUrl);\n    socket.onopen = () => {\n      console.log('[Worker] WebSocket connection established');\n      isConnected = true;\n      reconnectAttempts = 0;\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        isConnected: true\n      });\n\n      // Resubscribe to tokens after reconnection\n      if (activeSubscriptions.length > 0) {\n        subscribeToTokens(activeSubscriptions);\n      }\n\n      // Start sending periodic pings\n      startPingInterval();\n    };\n    socket.onclose = event => {\n      console.log(`[Worker] WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason || 'No reason provided'}, Clean: ${event.wasClean}`);\n      isConnected = false;\n      stopPingInterval();\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        isConnected: false\n      });\n\n      // Only try to reconnect if it wasn't a clean close\n      if (!event.wasClean) {\n        handleReconnect();\n      }\n    };\n    socket.onerror = error => {\n      console.error('[Worker] WebSocket error:', error);\n      self.postMessage({\n        type: 'ERROR',\n        error: 'Connection error. Attempting to reconnect...'\n      });\n    };\n    socket.onmessage = event => {\n      try {\n        const message = JSON.parse(event.data);\n        switch (message.type) {\n          case 'INITIAL_DATA':\n            self.postMessage({\n              type: 'INITIAL_DATA',\n              data: message.data\n            });\n            break;\n          case 'PRICE_UPDATE':\n            batchPriceUpdates(message.updates);\n            break;\n          case 'PONG':\n            // Received pong from the server - connection is active\n            break;\n          default:\n            console.log(`[Worker] Unknown message type: ${message.type}`);\n        }\n      } catch (error) {\n        console.error('[Worker] Error processing message:', error);\n      }\n    };\n  } catch (error) {\n    console.error('[Worker] Error creating WebSocket:', error);\n    isConnected = false;\n    handleReconnect();\n  }\n};\n\n// Batch price updates to reduce UI updates frequency\nconst batchPriceUpdates = updates => {\n  // Store the updates for batching\n  Object.entries(updates).forEach(([token, update]) => {\n    pendingUpdates[token] = update;\n  });\n\n  // If we already have a timeout scheduled, don't create another one\n  if (pendingUpdateTimeout) return;\n\n  // Schedule sending the batched updates\n  pendingUpdateTimeout = setTimeout(() => {\n    // Only send if we have updates and are connected\n    if (Object.keys(pendingUpdates).length > 0) {\n      console.log('[Worker] Sending batched price updates', pendingUpdates);\n      self.postMessage({\n        type: 'PRICE_UPDATE',\n        updates: pendingUpdates\n      });\n\n      // Clear the pending updates\n      pendingUpdates = {};\n    }\n\n    // Clear the timeout reference\n    pendingUpdateTimeout = null;\n  }, updateThrottle);\n};\n\n// Handle reconnection with exponential backoff\nconst handleReconnect = () => {\n  if (reconnectAttempts >= maxReconnectAttempts) {\n    console.error('[Worker] Maximum reconnection attempts reached');\n    self.postMessage({\n      type: 'ERROR',\n      error: 'Failed to reconnect after multiple attempts. Please refresh the page.'\n    });\n    return;\n  }\n  const delay = reconnectInterval * Math.pow(1.5, reconnectAttempts);\n  reconnectAttempts++;\n  self.postMessage({\n    type: 'RECONNECTING',\n    attempt: reconnectAttempts,\n    maxAttempts: maxReconnectAttempts\n  });\n  console.log(`[Worker] Reconnecting in ${delay}ms (attempt ${reconnectAttempts}/${maxReconnectAttempts})`);\n  setTimeout(connectToWebSocket, delay);\n};\n\n// Keep-alive mechanism\nlet pingInterval = null;\nconst startPingInterval = () => {\n  stopPingInterval(); // Clear any existing interval\n\n  pingInterval = setInterval(() => {\n    if (socket && socket.readyState === WebSocket.OPEN) {\n      socket.send(JSON.stringify({\n        type: 'PING'\n      }));\n    }\n  }, 30000); // Send ping every 30 seconds\n};\nconst stopPingInterval = () => {\n  if (pingInterval) {\n    clearInterval(pingInterval);\n    pingInterval = null;\n  }\n};\n\n// Token subscription management\nconst subscribeToTokens = tokens => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.warn('[Worker] Cannot subscribe, socket not open');\n    // Save for later when connected\n    tokens.forEach(token => {\n      if (!activeSubscriptions.includes(token)) {\n        activeSubscriptions.push(token);\n      }\n    });\n    return;\n  }\n\n  // Add to active subscriptions\n  tokens.forEach(token => {\n    if (!activeSubscriptions.includes(token)) {\n      activeSubscriptions.push(token);\n    }\n  });\n\n  // Send subscription message\n  socket.send(JSON.stringify({\n    type: 'SUBSCRIBE',\n    tokens: tokens\n  }));\n\n  // Notify the main thread\n  self.postMessage({\n    type: 'SUBSCRIPTION_UPDATE',\n    subscriptions: activeSubscriptions\n  });\n};\nconst unsubscribeFromTokens = tokens => {\n  // Remove from active subscriptions\n  activeSubscriptions = activeSubscriptions.filter(token => !tokens.includes(token));\n  if (socket && socket.readyState === WebSocket.OPEN) {\n    // Send unsubscription message\n    socket.send(JSON.stringify({\n      type: 'UNSUBSCRIBE',\n      tokens: tokens\n    }));\n  }\n\n  // Notify the main thread\n  self.postMessage({\n    type: 'SUBSCRIPTION_UPDATE',\n    subscriptions: activeSubscriptions\n  });\n};\n\n// Handle messages from the main thread\nself.onmessage = event => {\n  const message = event.data;\n  switch (message.type) {\n    case 'SUBSCRIBE':\n      subscribeToTokens(message.tokens);\n      break;\n    case 'UNSUBSCRIBE':\n      unsubscribeFromTokens(message.tokens);\n      break;\n    case 'GET_CONNECTION_STATUS':\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        isConnected: isConnected\n      });\n      break;\n    case 'DISCONNECT':\n      if (socket) {\n        socket.close(1000, 'User requested disconnect');\n      }\n      break;\n    default:\n      console.warn(`[Worker] Unknown message type from main thread: ${message.type}`);\n  }\n};\n\n// Start connection automatically\nconnectToWebSocket();","map":{"version":3,"names":["socket","reconnectAttempts","maxReconnectAttempts","reconnectInterval","activeSubscriptions","isConnected","pendingUpdates","pendingUpdateTimeout","updateThrottle","connectToWebSocket","onclose","onerror","close","err","console","error","wsUrl","log","WebSocket","onopen","self","postMessage","type","length","subscribeToTokens","startPingInterval","event","code","reason","wasClean","stopPingInterval","handleReconnect","onmessage","message","JSON","parse","data","batchPriceUpdates","updates","Object","entries","forEach","token","update","setTimeout","keys","delay","Math","pow","attempt","maxAttempts","pingInterval","setInterval","readyState","OPEN","send","stringify","clearInterval","tokens","warn","includes","push","subscriptions","unsubscribeFromTokens","filter"],"sources":["C:/Users/scr/OneDrive/Desktop/new/frontend/src/workers/websocketWorker.js"],"sourcesContent":["/* WebSocket Worker\n * This worker handles WebSocket connections independently from the main thread\n * Features:\n * - Auto reconnection on lost connections\n * - Bandwidth optimization through message batching\n * - Connection status monitoring\n */\n\n/* eslint-disable no-restricted-globals */\n// Using 'self' is standard in web workers, disabling ESLint warning\n\nlet socket = null;\nlet reconnectAttempts = 0;\nconst maxReconnectAttempts = 10;\nconst reconnectInterval = 2000; // 2 seconds\nlet activeSubscriptions = [];\nlet isConnected = false;\nlet pendingUpdates = {};\nlet pendingUpdateTimeout = null;\nconst updateThrottle = 150; // 150ms throttle for updates\n\n// Connection management\nconst connectToWebSocket = () => {\n  // Make sure any existing connection is closed\n  if (socket) {\n    try {\n      socket.onclose = null; // Remove the onclose handler to prevent reconnection loops\n      socket.onerror = null; // Remove the error handler\n      socket.close();\n    } catch (err) {\n      console.error('[Worker] Error closing existing socket:', err);\n    }\n  }\n\n  // Use a hardcoded URL to ensure we connect correctly\n  const wsUrl = 'ws://localhost:5000';\n  \n  console.log(`[Worker] Connecting to WebSocket at ${wsUrl}`);\n  \n  try {\n    socket = new WebSocket(wsUrl);\n    \n    socket.onopen = () => {\n      console.log('[Worker] WebSocket connection established');\n      isConnected = true;\n      reconnectAttempts = 0;\n      self.postMessage({ type: 'CONNECTION_STATUS', isConnected: true });\n      \n      // Resubscribe to tokens after reconnection\n      if (activeSubscriptions.length > 0) {\n        subscribeToTokens(activeSubscriptions);\n      }\n      \n      // Start sending periodic pings\n      startPingInterval();\n    };\n    \n    socket.onclose = (event) => {\n      console.log(`[Worker] WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason || 'No reason provided'}, Clean: ${event.wasClean}`);\n      isConnected = false;\n      stopPingInterval();\n      \n      self.postMessage({ type: 'CONNECTION_STATUS', isConnected: false });\n      \n      // Only try to reconnect if it wasn't a clean close\n      if (!event.wasClean) {\n        handleReconnect();\n      }\n    };\n    \n    socket.onerror = (error) => {\n      console.error('[Worker] WebSocket error:', error);\n      self.postMessage({ \n        type: 'ERROR', \n        error: 'Connection error. Attempting to reconnect...' \n      });\n    };\n    \n    socket.onmessage = (event) => {\n      try {\n        const message = JSON.parse(event.data);\n        \n        switch (message.type) {\n          case 'INITIAL_DATA':\n            self.postMessage({ type: 'INITIAL_DATA', data: message.data });\n            break;\n            \n          case 'PRICE_UPDATE':\n            batchPriceUpdates(message.updates);\n            break;\n            \n          case 'PONG':\n            // Received pong from the server - connection is active\n            break;\n            \n          default:\n            console.log(`[Worker] Unknown message type: ${message.type}`);\n        }\n      } catch (error) {\n        console.error('[Worker] Error processing message:', error);\n      }\n    };\n  } catch (error) {\n    console.error('[Worker] Error creating WebSocket:', error);\n    isConnected = false;\n    handleReconnect();\n  }\n};\n\n// Batch price updates to reduce UI updates frequency\nconst batchPriceUpdates = (updates) => {\n  // Store the updates for batching\n  Object.entries(updates).forEach(([token, update]) => {\n    pendingUpdates[token] = update;\n  });\n  \n  // If we already have a timeout scheduled, don't create another one\n  if (pendingUpdateTimeout) return;\n  \n  // Schedule sending the batched updates\n  pendingUpdateTimeout = setTimeout(() => {\n    // Only send if we have updates and are connected\n    if (Object.keys(pendingUpdates).length > 0) {\n      console.log('[Worker] Sending batched price updates', pendingUpdates);\n      self.postMessage({\n        type: 'PRICE_UPDATE',\n        updates: pendingUpdates\n      });\n      \n      // Clear the pending updates\n      pendingUpdates = {};\n    }\n    \n    // Clear the timeout reference\n    pendingUpdateTimeout = null;\n  }, updateThrottle);\n};\n\n// Handle reconnection with exponential backoff\nconst handleReconnect = () => {\n  if (reconnectAttempts >= maxReconnectAttempts) {\n    console.error('[Worker] Maximum reconnection attempts reached');\n    self.postMessage({ \n      type: 'ERROR',\n      error: 'Failed to reconnect after multiple attempts. Please refresh the page.'\n    });\n    return;\n  }\n  \n  const delay = reconnectInterval * Math.pow(1.5, reconnectAttempts);\n  reconnectAttempts++;\n  \n  self.postMessage({ \n    type: 'RECONNECTING',\n    attempt: reconnectAttempts, \n    maxAttempts: maxReconnectAttempts\n  });\n  \n  console.log(`[Worker] Reconnecting in ${delay}ms (attempt ${reconnectAttempts}/${maxReconnectAttempts})`);\n  \n  setTimeout(connectToWebSocket, delay);\n};\n\n// Keep-alive mechanism\nlet pingInterval = null;\n\nconst startPingInterval = () => {\n  stopPingInterval(); // Clear any existing interval\n  \n  pingInterval = setInterval(() => {\n    if (socket && socket.readyState === WebSocket.OPEN) {\n      socket.send(JSON.stringify({ type: 'PING' }));\n    }\n  }, 30000); // Send ping every 30 seconds\n};\n\nconst stopPingInterval = () => {\n  if (pingInterval) {\n    clearInterval(pingInterval);\n    pingInterval = null;\n  }\n};\n\n// Token subscription management\nconst subscribeToTokens = (tokens) => {\n  if (!socket || socket.readyState !== WebSocket.OPEN) {\n    console.warn('[Worker] Cannot subscribe, socket not open');\n    // Save for later when connected\n    tokens.forEach(token => {\n      if (!activeSubscriptions.includes(token)) {\n        activeSubscriptions.push(token);\n      }\n    });\n    return;\n  }\n  \n  // Add to active subscriptions\n  tokens.forEach(token => {\n    if (!activeSubscriptions.includes(token)) {\n      activeSubscriptions.push(token);\n    }\n  });\n  \n  // Send subscription message\n  socket.send(JSON.stringify({\n    type: 'SUBSCRIBE',\n    tokens: tokens\n  }));\n  \n  // Notify the main thread\n  self.postMessage({\n    type: 'SUBSCRIPTION_UPDATE',\n    subscriptions: activeSubscriptions\n  });\n};\n\nconst unsubscribeFromTokens = (tokens) => {\n  // Remove from active subscriptions\n  activeSubscriptions = activeSubscriptions.filter(\n    token => !tokens.includes(token)\n  );\n  \n  if (socket && socket.readyState === WebSocket.OPEN) {\n    // Send unsubscription message\n    socket.send(JSON.stringify({\n      type: 'UNSUBSCRIBE',\n      tokens: tokens\n    }));\n  }\n  \n  // Notify the main thread\n  self.postMessage({\n    type: 'SUBSCRIPTION_UPDATE',\n    subscriptions: activeSubscriptions\n  });\n};\n\n// Handle messages from the main thread\nself.onmessage = (event) => {\n  const message = event.data;\n  \n  switch (message.type) {\n    case 'SUBSCRIBE':\n      subscribeToTokens(message.tokens);\n      break;\n      \n    case 'UNSUBSCRIBE':\n      unsubscribeFromTokens(message.tokens);\n      break;\n      \n    case 'GET_CONNECTION_STATUS':\n      self.postMessage({\n        type: 'CONNECTION_STATUS',\n        isConnected: isConnected\n      });\n      break;\n      \n    case 'DISCONNECT':\n      if (socket) {\n        socket.close(1000, 'User requested disconnect');\n      }\n      break;\n      \n    default:\n      console.warn(`[Worker] Unknown message type from main thread: ${message.type}`);\n  }\n};\n\n// Start connection automatically\nconnectToWebSocket();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}