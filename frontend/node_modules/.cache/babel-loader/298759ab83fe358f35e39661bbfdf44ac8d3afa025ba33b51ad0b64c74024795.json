{"ast":null,"code":"// WebSocket service using a Web Worker for improved performance\nlet worker = null;\nlet eventHandlers = {\n  onInitialData: null,\n  onPriceUpdate: null,\n  onSubscriptionUpdate: null,\n  onConnectionStatus: null,\n  onReconnecting: null,\n  onError: null\n};\nlet isConnected = false;\nlet isInitialized = false;\nlet activeSubscriptions = []; // Track active subscriptions across component mounts\n\n// Initialize the worker\nconst initWorker = () => {\n  if (worker) return;\n\n  // Create the worker\n  worker = new Worker(new URL('../workers/websocketWorker.js', import.meta.url));\n\n  // Set up message listener\n  worker.onmessage = event => {\n    const message = event.data;\n    switch (message.type) {\n      case 'INITIAL_DATA':\n        if (eventHandlers.onInitialData) {\n          eventHandlers.onInitialData(message.data);\n        }\n        break;\n      case 'PRICE_UPDATE':\n        if (eventHandlers.onPriceUpdate) {\n          eventHandlers.onPriceUpdate(message.updates);\n        }\n        break;\n      case 'SUBSCRIPTION_UPDATE':\n        if (message.subscriptions) {\n          activeSubscriptions = [...message.subscriptions]; // Update cached subscriptions\n        }\n        if (eventHandlers.onSubscriptionUpdate) {\n          eventHandlers.onSubscriptionUpdate(message.subscriptions);\n        }\n        break;\n      case 'CONNECTION_STATUS':\n        isConnected = message.status === 'CONNECTED';\n        if (eventHandlers.onConnectionStatus) {\n          eventHandlers.onConnectionStatus(isConnected);\n        }\n        break;\n      case 'RECONNECTING':\n        if (eventHandlers.onReconnecting) {\n          eventHandlers.onReconnecting(message.attempt, message.maxAttempts);\n        }\n        break;\n      case 'ERROR':\n        if (eventHandlers.onError) {\n          eventHandlers.onError(message.error);\n        }\n        break;\n      default:\n        console.log('Unknown message type:', message.type);\n    }\n  };\n};\n\n// Connect to WebSocket and set up event handlers\nconst connectToWebSocket = handlers => {\n  // Initialize handler references\n  Object.keys(handlers || {}).forEach(key => {\n    if (handlers[key]) {\n      eventHandlers[key] = handlers[key];\n    }\n  });\n\n  // Initialize worker if needed\n  if (!isInitialized) {\n    initWorker();\n    isInitialized = true;\n\n    // Tell worker to connect (only first time)\n    worker.postMessage({\n      type: 'CONNECT'\n    });\n  } else {\n    // Update the new component with the current connection status\n    if (eventHandlers.onConnectionStatus) {\n      setTimeout(() => {\n        eventHandlers.onConnectionStatus(isConnected);\n      }, 0);\n    }\n\n    // Request current data if connected\n    if (isConnected && eventHandlers.onInitialData) {\n      worker.postMessage({\n        type: 'GET_INITIAL_DATA'\n      });\n    }\n\n    // Update new component with current subscriptions\n    if (activeSubscriptions.length > 0 && eventHandlers.onSubscriptionUpdate) {\n      setTimeout(() => {\n        eventHandlers.onSubscriptionUpdate(activeSubscriptions);\n      }, 0);\n    }\n  }\n};\n\n// Subscribe to tokens\nconst subscribeToTokens = tokens => {\n  if (!worker) {\n    console.error('Worker not initialized. Call connectToWebSocket first.');\n    return;\n  }\n  if (!Array.isArray(tokens)) {\n    tokens = [tokens];\n  }\n\n  // Update our cache of active subscriptions\n  tokens.forEach(token => {\n    if (!activeSubscriptions.includes(token)) {\n      activeSubscriptions.push(token);\n    }\n  });\n  worker.postMessage({\n    type: 'SUBSCRIBE',\n    tokens\n  });\n};\n\n// Unsubscribe from tokens\nconst unsubscribeFromTokens = tokens => {\n  if (!worker) {\n    console.error('Worker not initialized. Call connectToWebSocket first.');\n    return;\n  }\n  if (!Array.isArray(tokens)) {\n    tokens = [tokens];\n  }\n\n  // Update our cache of active subscriptions\n  activeSubscriptions = activeSubscriptions.filter(token => !tokens.includes(token));\n  worker.postMessage({\n    type: 'UNSUBSCRIBE',\n    tokens\n  });\n};\n\n// Disconnect from WebSocket\nconst disconnect = () => {\n  if (worker) {\n    // Clear all subscriptions on disconnect\n    activeSubscriptions = [];\n    worker.postMessage({\n      type: 'DISCONNECT'\n    });\n  }\n};\n\n// Check connection status\nconst getConnectionStatus = () => {\n  if (worker) {\n    worker.postMessage({\n      type: 'GET_CONNECTION_STATUS'\n    });\n  }\n  return isConnected;\n};\n\n// Get currently active subscriptions\nconst getActiveSubscriptions = () => {\n  return [...activeSubscriptions];\n};\nexport { connectToWebSocket, subscribeToTokens, unsubscribeFromTokens, disconnect, getConnectionStatus, getActiveSubscriptions };","map":{"version":3,"names":["worker","eventHandlers","onInitialData","onPriceUpdate","onSubscriptionUpdate","onConnectionStatus","onReconnecting","onError","isConnected","isInitialized","activeSubscriptions","initWorker","Worker","URL","import","meta","url","onmessage","event","message","data","type","updates","subscriptions","status","attempt","maxAttempts","error","console","log","connectToWebSocket","handlers","Object","keys","forEach","key","postMessage","setTimeout","length","subscribeToTokens","tokens","Array","isArray","token","includes","push","unsubscribeFromTokens","filter","disconnect","getConnectionStatus","getActiveSubscriptions"],"sources":["C:/Users/scr/OneDrive/Desktop/new/frontend/src/services/websocketService.js"],"sourcesContent":["// WebSocket service using a Web Worker for improved performance\nlet worker = null;\nlet eventHandlers = {\n  onInitialData: null,\n  onPriceUpdate: null,\n  onSubscriptionUpdate: null,\n  onConnectionStatus: null,\n  onReconnecting: null,\n  onError: null\n};\nlet isConnected = false;\nlet isInitialized = false;\nlet activeSubscriptions = []; // Track active subscriptions across component mounts\n\n// Initialize the worker\nconst initWorker = () => {\n  if (worker) return;\n  \n  // Create the worker\n  worker = new Worker(new URL('../workers/websocketWorker.js', import.meta.url));\n  \n  // Set up message listener\n  worker.onmessage = (event) => {\n    const message = event.data;\n    \n    switch (message.type) {\n      case 'INITIAL_DATA':\n        if (eventHandlers.onInitialData) {\n          eventHandlers.onInitialData(message.data);\n        }\n        break;\n      case 'PRICE_UPDATE':\n        if (eventHandlers.onPriceUpdate) {\n          eventHandlers.onPriceUpdate(message.updates);\n        }\n        break;\n      case 'SUBSCRIPTION_UPDATE':\n        if (message.subscriptions) {\n          activeSubscriptions = [...message.subscriptions]; // Update cached subscriptions\n        }\n        if (eventHandlers.onSubscriptionUpdate) {\n          eventHandlers.onSubscriptionUpdate(message.subscriptions);\n        }\n        break;\n      case 'CONNECTION_STATUS':\n        isConnected = message.status === 'CONNECTED';\n        if (eventHandlers.onConnectionStatus) {\n          eventHandlers.onConnectionStatus(isConnected);\n        }\n        break;\n      case 'RECONNECTING':\n        if (eventHandlers.onReconnecting) {\n          eventHandlers.onReconnecting(message.attempt, message.maxAttempts);\n        }\n        break;\n      case 'ERROR':\n        if (eventHandlers.onError) {\n          eventHandlers.onError(message.error);\n        }\n        break;\n      default:\n        console.log('Unknown message type:', message.type);\n    }\n  };\n};\n\n// Connect to WebSocket and set up event handlers\nconst connectToWebSocket = (handlers) => {\n  // Initialize handler references\n  Object.keys(handlers || {}).forEach(key => {\n    if (handlers[key]) {\n      eventHandlers[key] = handlers[key];\n    }\n  });\n  \n  // Initialize worker if needed\n  if (!isInitialized) {\n    initWorker();\n    isInitialized = true;\n    \n    // Tell worker to connect (only first time)\n    worker.postMessage({ type: 'CONNECT' });\n  } else {\n    // Update the new component with the current connection status\n    if (eventHandlers.onConnectionStatus) {\n      setTimeout(() => {\n        eventHandlers.onConnectionStatus(isConnected);\n      }, 0);\n    }\n    \n    // Request current data if connected\n    if (isConnected && eventHandlers.onInitialData) {\n      worker.postMessage({ type: 'GET_INITIAL_DATA' });\n    }\n    \n    // Update new component with current subscriptions\n    if (activeSubscriptions.length > 0 && eventHandlers.onSubscriptionUpdate) {\n      setTimeout(() => {\n        eventHandlers.onSubscriptionUpdate(activeSubscriptions);\n      }, 0);\n    }\n  }\n};\n\n// Subscribe to tokens\nconst subscribeToTokens = (tokens) => {\n  if (!worker) {\n    console.error('Worker not initialized. Call connectToWebSocket first.');\n    return;\n  }\n  \n  if (!Array.isArray(tokens)) {\n    tokens = [tokens];\n  }\n  \n  // Update our cache of active subscriptions\n  tokens.forEach(token => {\n    if (!activeSubscriptions.includes(token)) {\n      activeSubscriptions.push(token);\n    }\n  });\n  \n  worker.postMessage({\n    type: 'SUBSCRIBE',\n    tokens\n  });\n};\n\n// Unsubscribe from tokens\nconst unsubscribeFromTokens = (tokens) => {\n  if (!worker) {\n    console.error('Worker not initialized. Call connectToWebSocket first.');\n    return;\n  }\n  \n  if (!Array.isArray(tokens)) {\n    tokens = [tokens];\n  }\n  \n  // Update our cache of active subscriptions\n  activeSubscriptions = activeSubscriptions.filter(token => !tokens.includes(token));\n  \n  worker.postMessage({\n    type: 'UNSUBSCRIBE',\n    tokens\n  });\n};\n\n// Disconnect from WebSocket\nconst disconnect = () => {\n  if (worker) {\n    // Clear all subscriptions on disconnect\n    activeSubscriptions = [];\n    worker.postMessage({ type: 'DISCONNECT' });\n  }\n};\n\n// Check connection status\nconst getConnectionStatus = () => {\n  if (worker) {\n    worker.postMessage({ type: 'GET_CONNECTION_STATUS' });\n  }\n  return isConnected;\n};\n\n// Get currently active subscriptions\nconst getActiveSubscriptions = () => {\n  return [...activeSubscriptions];\n};\n\nexport {\n  connectToWebSocket,\n  subscribeToTokens,\n  unsubscribeFromTokens,\n  disconnect,\n  getConnectionStatus,\n  getActiveSubscriptions\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}