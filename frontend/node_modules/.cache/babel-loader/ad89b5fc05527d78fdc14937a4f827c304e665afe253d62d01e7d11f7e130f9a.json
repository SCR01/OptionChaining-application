{"ast":null,"code":"// WebSocket service using a Web Worker for improved performance\nlet worker = null;\nlet eventHandlers = {};\n\n// Initialize the worker\nconst initWorker = () => {\n  if (worker) return;\n\n  // Create the worker\n  worker = new Worker(new URL('../workers/websocketWorker.js', import.meta.url));\n\n  // Set up message listener\n  worker.onmessage = event => {\n    const message = event.data;\n    switch (message.type) {\n      case 'INITIAL_DATA':\n        if (eventHandlers.onInitialData) {\n          eventHandlers.onInitialData(message.data);\n        }\n        break;\n      case 'PRICE_UPDATE':\n        if (eventHandlers.onPriceUpdate) {\n          eventHandlers.onPriceUpdate(message.data);\n        }\n        break;\n      case 'MARKET_STATE':\n        if (eventHandlers.onMarketState) {\n          eventHandlers.onMarketState(message.data);\n        }\n        break;\n      case 'SUBSCRIPTION_UPDATE':\n        if (eventHandlers.onSubscriptionUpdate) {\n          eventHandlers.onSubscriptionUpdate(message.subscriptions);\n        }\n        break;\n      case 'CONNECTION_STATUS':\n        if (eventHandlers.onConnectionStatus) {\n          eventHandlers.onConnectionStatus(message.isConnected);\n        }\n        break;\n      case 'RECONNECTING':\n        if (eventHandlers.onReconnecting) {\n          eventHandlers.onReconnecting(message.attempt, message.maxAttempts);\n        }\n        break;\n      case 'ERROR':\n        if (eventHandlers.onError) {\n          eventHandlers.onError(new Error(message.error));\n        }\n        break;\n      default:\n        console.warn(`Unknown message type from worker: ${message.type}`);\n    }\n  };\n\n  // Handle worker errors\n  worker.onerror = error => {\n    console.error('WebSocket worker error:', error);\n    if (eventHandlers.onError) {\n      eventHandlers.onError(new Error('WebSocket worker error'));\n    }\n  };\n};\n\n// Connect to WebSocket and set up event handlers\nconst connectToWebSocket = handlers => {\n  eventHandlers = handlers || {};\n  initWorker();\n\n  // Tell the worker to connect\n  worker.postMessage({\n    type: 'CONNECT'\n  });\n\n  // Request the current connection status\n  worker.postMessage({\n    type: 'GET_STATUS'\n  });\n};\n\n// Subscribe to tokens\nconst subscribeToTokens = tokens => {\n  if (!worker) {\n    console.warn('Worker not initialized, cannot subscribe');\n    return;\n  }\n  worker.postMessage({\n    type: 'SUBSCRIBE',\n    tokens: tokens\n  });\n};\n\n// Unsubscribe from tokens\nconst unsubscribeFromTokens = tokens => {\n  if (!worker) {\n    console.warn('Worker not initialized, cannot unsubscribe');\n    return;\n  }\n  worker.postMessage({\n    type: 'UNSUBSCRIBE',\n    tokens: tokens\n  });\n};\n\n// Disconnect from WebSocket\nconst disconnect = () => {\n  if (!worker) return;\n  worker.postMessage({\n    type: 'DISCONNECT'\n  });\n};\n\n// Check connection status\nconst getConnectionStatus = () => {\n  if (!worker) return false;\n  worker.postMessage({\n    type: 'GET_STATUS'\n  });\n};\nexport { connectToWebSocket, subscribeToTokens, unsubscribeFromTokens, disconnect, getConnectionStatus };","map":{"version":3,"names":["worker","eventHandlers","initWorker","Worker","URL","import","meta","url","onmessage","event","message","data","type","onInitialData","onPriceUpdate","onMarketState","onSubscriptionUpdate","subscriptions","onConnectionStatus","isConnected","onReconnecting","attempt","maxAttempts","onError","Error","error","console","warn","onerror","connectToWebSocket","handlers","postMessage","subscribeToTokens","tokens","unsubscribeFromTokens","disconnect","getConnectionStatus"],"sources":["C:/Users/scr/OneDrive/Desktop/new/frontend/src/services/websocketService.js"],"sourcesContent":["// WebSocket service using a Web Worker for improved performance\nlet worker = null;\nlet eventHandlers = {};\n\n// Initialize the worker\nconst initWorker = () => {\n  if (worker) return;\n  \n  // Create the worker\n  worker = new Worker(new URL('../workers/websocketWorker.js', import.meta.url));\n  \n  // Set up message listener\n  worker.onmessage = (event) => {\n    const message = event.data;\n    \n    switch (message.type) {\n      case 'INITIAL_DATA':\n        if (eventHandlers.onInitialData) {\n          eventHandlers.onInitialData(message.data);\n        }\n        break;\n      case 'PRICE_UPDATE':\n        if (eventHandlers.onPriceUpdate) {\n          eventHandlers.onPriceUpdate(message.data);\n        }\n        break;\n      case 'MARKET_STATE':\n        if (eventHandlers.onMarketState) {\n          eventHandlers.onMarketState(message.data);\n        }\n        break;\n      case 'SUBSCRIPTION_UPDATE':\n        if (eventHandlers.onSubscriptionUpdate) {\n          eventHandlers.onSubscriptionUpdate(message.subscriptions);\n        }\n        break;\n      case 'CONNECTION_STATUS':\n        if (eventHandlers.onConnectionStatus) {\n          eventHandlers.onConnectionStatus(message.isConnected);\n        }\n        break;\n      case 'RECONNECTING':\n        if (eventHandlers.onReconnecting) {\n          eventHandlers.onReconnecting(message.attempt, message.maxAttempts);\n        }\n        break;\n      case 'ERROR':\n        if (eventHandlers.onError) {\n          eventHandlers.onError(new Error(message.error));\n        }\n        break;\n      default:\n        console.warn(`Unknown message type from worker: ${message.type}`);\n    }\n  };\n  \n  // Handle worker errors\n  worker.onerror = (error) => {\n    console.error('WebSocket worker error:', error);\n    if (eventHandlers.onError) {\n      eventHandlers.onError(new Error('WebSocket worker error'));\n    }\n  };\n};\n\n// Connect to WebSocket and set up event handlers\nconst connectToWebSocket = (handlers) => {\n  eventHandlers = handlers || {};\n  \n  initWorker();\n  \n  // Tell the worker to connect\n  worker.postMessage({ type: 'CONNECT' });\n  \n  // Request the current connection status\n  worker.postMessage({ type: 'GET_STATUS' });\n};\n\n// Subscribe to tokens\nconst subscribeToTokens = (tokens) => {\n  if (!worker) {\n    console.warn('Worker not initialized, cannot subscribe');\n    return;\n  }\n  \n  worker.postMessage({\n    type: 'SUBSCRIBE',\n    tokens: tokens\n  });\n};\n\n// Unsubscribe from tokens\nconst unsubscribeFromTokens = (tokens) => {\n  if (!worker) {\n    console.warn('Worker not initialized, cannot unsubscribe');\n    return;\n  }\n  \n  worker.postMessage({\n    type: 'UNSUBSCRIBE',\n    tokens: tokens\n  });\n};\n\n// Disconnect from WebSocket\nconst disconnect = () => {\n  if (!worker) return;\n  \n  worker.postMessage({ type: 'DISCONNECT' });\n};\n\n// Check connection status\nconst getConnectionStatus = () => {\n  if (!worker) return false;\n  \n  worker.postMessage({ type: 'GET_STATUS' });\n};\n\nexport {\n  connectToWebSocket,\n  subscribeToTokens,\n  unsubscribeFromTokens,\n  disconnect,\n  getConnectionStatus\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}