{"ast":null,"code":"// WebSocket service using a Web Worker for improved performance\nlet worker = null;\nlet eventHandlers = {\n  onInitialData: null,\n  onPriceUpdate: null,\n  onSubscriptionUpdate: null,\n  onConnectionStatus: null,\n  onReconnecting: null,\n  onError: null\n};\nlet isConnected = false;\nlet isInitialized = false;\n\n// Initialize the worker\nconst initWorker = () => {\n  if (worker) return;\n\n  // Create the worker\n  worker = new Worker(new URL('../workers/websocketWorker.js', import.meta.url));\n\n  // Set up message listener\n  worker.onmessage = event => {\n    const message = event.data;\n    switch (message.type) {\n      case 'INITIAL_DATA':\n        if (eventHandlers.onInitialData) {\n          eventHandlers.onInitialData(message.data);\n        }\n        break;\n      case 'PRICE_UPDATE':\n        if (eventHandlers.onPriceUpdate) {\n          eventHandlers.onPriceUpdate(message.updates);\n        }\n        break;\n      case 'SUBSCRIPTION_UPDATE':\n        if (eventHandlers.onSubscriptionUpdate) {\n          eventHandlers.onSubscriptionUpdate(message.subscriptions);\n        }\n        break;\n      case 'CONNECTION_STATUS':\n        isConnected = message.status === 'CONNECTED';\n        if (eventHandlers.onConnectionStatus) {\n          eventHandlers.onConnectionStatus(isConnected);\n        }\n        break;\n      case 'RECONNECTING':\n        if (eventHandlers.onReconnecting) {\n          eventHandlers.onReconnecting(message.attempt, message.maxAttempts);\n        }\n        break;\n      case 'ERROR':\n        if (eventHandlers.onError) {\n          eventHandlers.onError(message.error);\n        }\n        break;\n      default:\n        console.log('Unknown message type:', message.type);\n    }\n  };\n\n  // Handle worker errors\n  worker.onerror = error => {\n    console.error('WebSocket worker error:', error);\n    if (eventHandlers.onError) {\n      eventHandlers.onError(new Error('WebSocket worker error'));\n    }\n  };\n};\n\n// Connect to WebSocket and set up event handlers\nconst connectToWebSocket = handlers => {\n  // Initialize handler references\n  Object.keys(handlers || {}).forEach(key => {\n    if (handlers[key]) {\n      eventHandlers[key] = handlers[key];\n    }\n  });\n\n  // Initialize worker if needed\n  if (!isInitialized) {\n    initWorker();\n    isInitialized = true;\n\n    // Tell worker to connect (only first time)\n    worker.postMessage({\n      type: 'CONNECT'\n    });\n  } else {\n    // Update the new component with the current connection status\n    if (eventHandlers.onConnectionStatus) {\n      setTimeout(() => {\n        eventHandlers.onConnectionStatus(isConnected);\n      }, 0);\n    }\n\n    // Request current data if connected\n    if (isConnected && eventHandlers.onInitialData) {\n      worker.postMessage({\n        type: 'GET_INITIAL_DATA'\n      });\n    }\n  }\n};\n\n// Subscribe to tokens\nconst subscribeToTokens = tokens => {\n  if (!worker) {\n    console.error('Worker not initialized. Call connectToWebSocket first.');\n    return;\n  }\n  if (!Array.isArray(tokens)) {\n    tokens = [tokens];\n  }\n  worker.postMessage({\n    type: 'SUBSCRIBE',\n    tokens\n  });\n};\n\n// Unsubscribe from tokens\nconst unsubscribeFromTokens = tokens => {\n  if (!worker) {\n    console.error('Worker not initialized. Call connectToWebSocket first.');\n    return;\n  }\n  if (!Array.isArray(tokens)) {\n    tokens = [tokens];\n  }\n  worker.postMessage({\n    type: 'UNSUBSCRIBE',\n    tokens\n  });\n};\n\n// Disconnect from WebSocket\nconst disconnect = () => {\n  if (worker) {\n    worker.postMessage({\n      type: 'DISCONNECT'\n    });\n  }\n};\n\n// Check connection status\nconst getConnectionStatus = () => {\n  if (worker) {\n    worker.postMessage({\n      type: 'GET_CONNECTION_STATUS'\n    });\n  }\n  return isConnected;\n};\nexport { connectToWebSocket, subscribeToTokens, unsubscribeFromTokens, disconnect, getConnectionStatus };","map":{"version":3,"names":["worker","eventHandlers","onInitialData","onPriceUpdate","onSubscriptionUpdate","onConnectionStatus","onReconnecting","onError","isConnected","isInitialized","initWorker","Worker","URL","import","meta","url","onmessage","event","message","data","type","updates","subscriptions","status","attempt","maxAttempts","error","console","log","onerror","Error","connectToWebSocket","handlers","Object","keys","forEach","key","postMessage","setTimeout","subscribeToTokens","tokens","Array","isArray","unsubscribeFromTokens","disconnect","getConnectionStatus"],"sources":["C:/Users/scr/OneDrive/Desktop/new/frontend/src/services/websocketService.js"],"sourcesContent":["// WebSocket service using a Web Worker for improved performance\nlet worker = null;\nlet eventHandlers = {\n  onInitialData: null,\n  onPriceUpdate: null,\n  onSubscriptionUpdate: null,\n  onConnectionStatus: null,\n  onReconnecting: null,\n  onError: null\n};\nlet isConnected = false;\nlet isInitialized = false;\n\n// Initialize the worker\nconst initWorker = () => {\n  if (worker) return;\n  \n  // Create the worker\n  worker = new Worker(new URL('../workers/websocketWorker.js', import.meta.url));\n  \n  // Set up message listener\n  worker.onmessage = (event) => {\n    const message = event.data;\n    \n    switch (message.type) {\n      case 'INITIAL_DATA':\n        if (eventHandlers.onInitialData) {\n          eventHandlers.onInitialData(message.data);\n        }\n        break;\n      case 'PRICE_UPDATE':\n        if (eventHandlers.onPriceUpdate) {\n          eventHandlers.onPriceUpdate(message.updates);\n        }\n        break;\n      case 'SUBSCRIPTION_UPDATE':\n        if (eventHandlers.onSubscriptionUpdate) {\n          eventHandlers.onSubscriptionUpdate(message.subscriptions);\n        }\n        break;\n      case 'CONNECTION_STATUS':\n        isConnected = message.status === 'CONNECTED';\n        if (eventHandlers.onConnectionStatus) {\n          eventHandlers.onConnectionStatus(isConnected);\n        }\n        break;\n      case 'RECONNECTING':\n        if (eventHandlers.onReconnecting) {\n          eventHandlers.onReconnecting(message.attempt, message.maxAttempts);\n        }\n        break;\n      case 'ERROR':\n        if (eventHandlers.onError) {\n          eventHandlers.onError(message.error);\n        }\n        break;\n      default:\n        console.log('Unknown message type:', message.type);\n    }\n  };\n  \n  // Handle worker errors\n  worker.onerror = (error) => {\n    console.error('WebSocket worker error:', error);\n    if (eventHandlers.onError) {\n      eventHandlers.onError(new Error('WebSocket worker error'));\n    }\n  };\n};\n\n// Connect to WebSocket and set up event handlers\nconst connectToWebSocket = (handlers) => {\n  // Initialize handler references\n  Object.keys(handlers || {}).forEach(key => {\n    if (handlers[key]) {\n      eventHandlers[key] = handlers[key];\n    }\n  });\n  \n  // Initialize worker if needed\n  if (!isInitialized) {\n    initWorker();\n    isInitialized = true;\n    \n    // Tell worker to connect (only first time)\n    worker.postMessage({ type: 'CONNECT' });\n  } else {\n    // Update the new component with the current connection status\n    if (eventHandlers.onConnectionStatus) {\n      setTimeout(() => {\n        eventHandlers.onConnectionStatus(isConnected);\n      }, 0);\n    }\n    \n    // Request current data if connected\n    if (isConnected && eventHandlers.onInitialData) {\n      worker.postMessage({ type: 'GET_INITIAL_DATA' });\n    }\n  }\n};\n\n// Subscribe to tokens\nconst subscribeToTokens = (tokens) => {\n  if (!worker) {\n    console.error('Worker not initialized. Call connectToWebSocket first.');\n    return;\n  }\n  \n  if (!Array.isArray(tokens)) {\n    tokens = [tokens];\n  }\n  \n  worker.postMessage({\n    type: 'SUBSCRIBE',\n    tokens\n  });\n};\n\n// Unsubscribe from tokens\nconst unsubscribeFromTokens = (tokens) => {\n  if (!worker) {\n    console.error('Worker not initialized. Call connectToWebSocket first.');\n    return;\n  }\n  \n  if (!Array.isArray(tokens)) {\n    tokens = [tokens];\n  }\n  \n  worker.postMessage({\n    type: 'UNSUBSCRIBE',\n    tokens\n  });\n};\n\n// Disconnect from WebSocket\nconst disconnect = () => {\n  if (worker) {\n    worker.postMessage({ type: 'DISCONNECT' });\n  }\n};\n\n// Check connection status\nconst getConnectionStatus = () => {\n  if (worker) {\n    worker.postMessage({ type: 'GET_CONNECTION_STATUS' });\n  }\n  return isConnected;\n};\n\nexport {\n  connectToWebSocket,\n  subscribeToTokens,\n  unsubscribeFromTokens,\n  disconnect,\n  getConnectionStatus\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}